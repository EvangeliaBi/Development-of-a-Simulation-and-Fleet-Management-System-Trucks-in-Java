package simulatorengine;	 // Η κλάση αυτή ανήκει στο συγκεκριμένο πακέτο, δηλαδή στο layer της προσομοίωσης (simulation layer), καθώς με αυτόν τον τρόπο διαχωρίζονται οι κλάσεις που βρίσκονται στο πακέτο simulator, δηλαδή στο data access (DAO), από την στιγμή που αυτή η κλάση είναι υπεύθυνη για το business logic / simulation logic σύμφωνα με την αρχιτεκτονική separation of concerns.

// Τα παρακάτω imports εξασφαλίζουν ότι η SimulationEngine μπορεί να χειριστεί λίστες και χάρτες δεδομένων αποδοτικά, χωρίς να χρειάζεται η υλοποίηση δομών δεδομένων.
import java.util.List;		// Εισαγωγή της διεπαφής List από το πακέτο java.util, όπου το List είναι μια ακολουθιακή συλλογή (ordered collection) που μπορεί να περιέχει διπλότυπα στοιχεία, καθώς στην προσομοίωση χρησιμοποιείται για να αποθηκεύσουμε λίστες πελατών ή λίστες πόλεων/διαδρομών από την στιγμή που η χρήση του List επιτρέπει εύκολη επανάληψη με for-each, πρόσβαση με index, και δυναμικό μέγεθος. Επιπλέον δεν παρέχεται συγκεκριμένη υλοποίηση (πχ. ArrayList), καθώς χρησιμοποιείται abstraction.
import java.util.Map;		// Εδώ εισάγεται η διεπαφή Map από το πακέτο java.util, καθώς το Map είναι μια δομή key-value, όπου κάθε key αντιστοιχεί σε μια μοναδική τιμή, όπου στην προσομοίωση χρησιμοποιείται, όταν θέλουμε για παράδειγμα να αποθηκεύσουμε routeCode (κωδικός συγκεκριμένου δρομολογίου) μαζί με συνολική απόσταση για αυτό το συγκεκριμένο δρομολόγιο, καθώς η διεπαφή Map μας επιτρέπει να δουλεύουμε γενικά, ανεξάρτητα από την υλοποίηση (HashMap, TreeMap), δίνοντας την δυνατότητα γρηγορότερης αναζήτησης, εισαγωγής και ενημέρωσης των στοιχείων μέσω του key.
import java.util.HashMap;	// Εδώ εισάγεται η κλάση HashMap η οποία είναι μια συγκεκριμένη υλοποίηση της διεπαφής Map, αποθηκεύοντας key-value ζεύγη σε hash table, καθώς στην κλάση αυτή (SimulationEngine) χρησιμοποιείται για το hourlySchedule ή για το routeDistances, από την στιγμή που είναι απαραίτητη η γρήγορη πρόσβαση σε δεδομένα με key (routeCode, ώρα) καθιστώντας την χρήση του HashMap ως την πιο αποδοτική επιλογή.

// Αυτά τα imports επιτρέπουν στη SimulationEngine να χρησιμοποιεί τα δεδομένα και τις λειτουργίες των DAO κλάσεων, χωρίς να χρειάζεται να ξαναδημιουργήσει τα μοντέλα (Customer, Truck) ή να ξαναγράψει SQL queries προς την βάση δεδομένων για τα routes (=διαδρομές).
import simulator.RouteDAO;		// Εισαγωγή της κλάσης RouteDAO από το πακέτο simulator, καθώς η κλάση RouteDAO είναι η κλάση που χειρίζεται τις διαδρομές (routes) και τις πληροφορίες αυτών από τη βάση δεδομένων. Μέσα στη SimulationEngine, χρησιμοποιούμε την κλάση RouteDAO, για να πάρουμε π.χ. τις συνολικές αποστάσεις των routes (getRoutesWithDistances()) ή τις λίστες πόλεων για τις στάσεις του κάθε route (getRouteStops(routeCode)). Πιο συγκεκριμένα είναι απαραίτητη η πρόσβαση σε δεδομένα διαδρομών για τον προγραμματισμό των trips των φορτηγών. Πρόσβαση σε διαδρομές και αποστάσεις.
import simulator.CustomerDAO.Customer;		// Εισαγωγή της ένθετης κλάσης (nested) class Customer από την κλάση CustomerDAO, καθώς η κλάση Customer αναπαριστά έναν πελάτη με όλα τα πεδία του (id, city, type, weeklyTrips, volumePerTrip κλπ.). Πιο συγκεκριμένα στην κλάση SimulationEngine, χρησιμοποιούμε αντικείμενα Customer για να προγραμματίσουμε ποιοι πελάτες έχουν trips σε ποιες ώρες και ποια είναι η ποσότητα του προϊόντος που πρέπει να μεταφερθεί. Επίσης η εισαγωγή γίνεται με full path γιατί η Customer είναι static nested class μέσα στην CustomerDAO, από την στιγμή που χρειαζόμαστε μοντέλο πελάτη για όλες τις λειτουργίες της προσομοίωσης. Μοντέλο πελάτη με δρομολόγια και όγκο προϊόντων.
import simulator.TruckDAO.Truck;		// Εισαγωγή της ένθετης (nested) κλάσης Truck από την κλάση TruckDAO, καθώς η κλάση Truck αναπαριστά ένα φορτηγό, με πεδία category, capacity και quantity. Πιο συγκεκριμένα στην κλάση SimulationEngine, χρησιμοποιούμε αντικείμενα Truck για να υπολογίσουμε πόσα trips (πόσες διαδρομές) χρειάζονται για να καλυφθεί ο συνολικός όγκος προϊόντων, καθώς και για τον υπολογισμό κόστους και κέρδους. Η εισαγωγή γίνεται με πλήρες path λόγω της static nested class φύσης της Truck, καθώς χρειαζόμαστε μοντέλο φορτηγού για να προσομοιώσουμε τη μεταφορά προϊόντων και την οικονομική ανάλυση. Μοντέλο φορτηγού με κατηγορία, χωρητικότητα και διαθέσιμα οχήματα.

// Η αρχιτεκτονική που ακολουθείται στην συγκεκριμένη κλάση είναι η Data-Driven Simulation, όπου η λογική της SimulationEngine χρησιμοποιεί δεδομένα από τις DAO κλάσεις και δεν εστιάζει στη δημιουργία τους.
public class SimulationEngine {		// Η κλάση αυτή είναι υπεύθυνη για την εκτέλεση προσομοιώσεων (simulation) δρομολογίων φορτηγών για πελάτες, καθώς μπορεί να χρησιμοποιηθεί από οποιαδήποτε άλλη κλάση/πακέτο. Μέσω της κλάσης αυτής ενσωματώνεται η λογική προσομοίωσης, δηλαδή παίρνει δεδομένα (πελάτες, διαδρομές, φορτηγά) και υπολογίζει τις διαδρομές (trips), τα κέρδη, τα κόστη, κλπ.

    private List<Customer> customers;		// Το πεδίο customers είναι μία λίστα αντικειμένων τύπου Customer, όπου στην ουσία αποθηκεύει όλους τους πελάτες που θα συμμετέχουν στη simulation, καθώς μόνο η κλάση SimulationEngine έχει πρόσβαση σε αυτό το πεδίο. Η ύπαρξη αυτού του πεδίου βοηθά στο γεγονός ότι είναι απαραίτητη η χρήση πελατών για να ξέρουμε ποιος έχει δρομολόγιο, σε ποια πόλη, σε ποιον όγκο προϊόντος κλπ.
    private Map<String, Double> routeDistances; 	// Το πεδίο αυτό είναι ένα map, όπου το Key (String) είναι ο κωδικός διαδρομής (routeCode) και το Value (Double) είναι η συνολική απόσταση της διαδρομής σε χιλιόμετρα (km), καθώς αυτό το πεδίο είναι προσβάσιμο μόνο μέσα στην κλάση αυτή. Είναι απαραίτητη η χρήση αυτού του πεδίου, προκειμένου να ξέρουμε πόσο μακριά είναι η κάθε διαδρομή, ώστε να υπολογίσουμε τα trips, το κόστος και τα έσοδα.
    private Truck truck;		// Σε αυτό το πεδίο αποθηκεύεται ένα αντικείμενο τύπου Truck, καθώς αντιπροσωπεύει το φορτηγό που θα χρησιμοποιηθεί στη simulation, περιέχοντας κατηγορία, χωρητικότητα (σε προϊόν) και διαθέσιμα οχήματα. Είναι απαραίτητη η χρήση αυτού του πεδίου καθώς πρέπει να γνωρίζουμε πόσο φορτίο μπορεί να μεταφερθεί σε κάθε ταξίδι και πόσα φορτηγά είναι διαθέσιμα.
    private String warehouseType;		// Σε αυτό το πεδίο αποθηκεύεται ο τύπος αποθήκης ("SHORT" ή "LONG"), καθώς χρησιμοποιείται για να φιλτράρουμε πελάτες και routes που μπορούν να εξυπηρετηθούν ανάλογα με τον τύπο αποθήκης, διαχωρίζοντας τα δρομολόγια ανά τύπο αποθήκης για την σωστή προσωμοίωση.

    // Δημιουργία κατασκευαστή, όπου χρησιμοποιείται για να δημιουργήσουμε ένα πλήρως αρχικοποιημένο αντικείμενο SimulationEngine (δηλαδή δεν χρειάζεται επιπλέον ρύθμιση πριν τρέξει η simulation), καθώς δέχεται ως ορίσματα λίστα πελατών (customers), Map διαδρομών και αποστάσεων (routeDistances), το φορτηγό (truck) και τον τύπο αποθήκης (warehouseType).
    public SimulationEngine(List<Customer> customers, Map<String, Double> routeDistances, Truck truck, String warehouseType) {
        this.customers = customers;
        this.routeDistances = routeDistances;
        this.truck = truck;
        this.warehouseType = warehouseType;
    }

    
    public String runDeterministicSimulationToString() {	// Η συγεκριμένη public μέθοδος καλείται για να τρέξει μια deterministic simulation, δηλαδή μία simulation με προκαθορισμένες, σταθερές ώρες δρομολογίων για κάθε πελάτη, καθώς δεν δέχεται κάποια παράμετρο εισόδου επιστρέφοντας ένα String, που περιέχει τα αποτελέσματα της προσομοίωσης (π.χ., συνολικές διαδρομές, έσοδα, κόστος, κέρδος). Στην ουσία καλεί την κοινή μέθοδο runHourlySimulationToString με όρισμα false, που σημαίνει ότι δεν θα χρησιμοποιηθούν τυχαίες ώρες. 
        return runHourlySimulationToString(false);
    }

    
    public String runStochasticSimulationToString() {		// Σε αυτή την stochastic simulation, τίθεται ως όρισμα της μεθόδου runHourlySimulationToString η τιμή true, διότι οι ώρες των δρομολογίων επιλέγονται τυχαία μέσω της μεθόδου Customer.getRandomTripHours() επιστρέφοντας ένα String με τα αποτελέσματα.
        return runHourlySimulationToString(true);
    }

    
    // Κοινή μέθοδος για hourly simulations με επιστροφή String.
    private String runHourlySimulationToString(boolean stochastic) {	// Πρόκειται για την κύρια μέθοδο προσομοίωσης, η οποία είναι κοινή και για τις 2 προσομοιώσεις deterministic και stochastic, καθώς η μέθοδος λαμβάνει ως παράμετρο εισόδου μία boolean τιμή (stochastic) που καθορίζει αν τα trips θα είναι τυχαία ή προκαθορισμένα, ενώ δηλώνεται ως private που σημαίνει ότι δεν μπορεί να κληθεί έξω από την κλάση SimulationEngine.
        int totalHours = 24 * 7 * 26; 			// Σε αυτό το σημείο υπολογίζεται ο συνολικός αριθμός ωρών της προσομοίωσης, καθώς 24 ώρες/ημέρα × 7 ημέρες/εβδομάδα × 26 εβδομάδες (6 μήνες). Ο υπολογισμός αυτός είναι απαραίτητος για την ωριαία προσομοίωση (hourly simulation).
        // Παρακάτω αρχικοποιούνται οι μεταβλητές που θα χρησιμοποιηθούν για τα συνολικά αποτελέσματα της simulation.
        int totalTrips = 0;		// συνολικός αριθμός ταξιδιών (trips) που εκτελέστηκαν καθώς είναι 0 στην αρχή γιατί δεν έχει τρέξει ακόμα η προσμοίωση.
        double totalRevenue = 0;	// συνολικά έσοδα (€) που αρχικώς είναι 0.
        double totalCost = 0;		// συνολικό κόστος (€) που αρχικώς είναι 0.

        
        Map<Integer, List<Customer>> hourlySchedule = new HashMap<>();		// Σε αυτό το σημείο δημιουργείται ένα map όπου το key είναι η ώρα (0 έως totalHours-1) και το value είναι η λίστα πελατών που έχουν προγραμματισμένο δρομολόγιο/trip σε αυτή την ώρα, καθώς η χρήση HashMap επιτρέπει γρήγορη αναζήτηση ανά ώρα για την εκτέλεση των trips.

        
        // Δημιουργία schedule ανά πελάτη.
        for (Customer c : customers) {		// Μέσω του επαναληπτικού βρόγχου (for), διατρέχονται όλοι οι πελάτες (Customer) της λίστας customers, καθώς για κάθε πελάτη θέλουμε να δημιουργηθεί το ωρολόγιο πρόγραμμα δρομολογίων (hourly schedule).
            for (int week = 0; week < 26; week++) {		// Μέσω της ένθετης επαναληπτικής δομής διατρέχεται η κάθε εβδομάδα από τις 26 εβδομάδες που αντιστοιχούν σε 6 μήνες, καθώς το week χρησιμοποιείται για να μεταθέσει τις ώρες του κάθε ταξιδιού κατά τις επόμενες εβδομάδες.
                List<Integer> tripHours = stochastic ? c.getRandomTripHours() : c.getTripHours();		// Σε αυτό το σημείο εάν η προσομοίωση είναι stochastic (true), τότε επιλέγονται τυχαίες ώρες δρομολογίων για τον πελάτη (c.getRandomTripHours()), διαφορετικές κάθε εβδομάδα. Αν η προσομοίωση είναι deterministic (false), τότε τα δρομολόγια είναι ισοκατανεμημένα μέσα στην εβδομάδα (c.getTripHours()), καθώς το αποτέλεσμα είναι μια λίστα από ώρες μέσα στην εβδομάδα (0–167).
                for (int h : tripHours) {		// Μέσω της enhanced for διατρέχεται κάθε ώρα δρομολογίου (h) από τη λίστα tripHours, καθώς ο σκοπός είναι να τοποθετήσει κάθε δρομολόγιο στη σωστή ώρα του συνολικού προγράμματος των 6 μηνών.
                    int hour = h + week * 168;		// Εδώ υπολογίζεται η ώρα του δρομολογίου στο συνολικό 6μηνο χρονικό διάστημα, καθώς το h είναι η ώρα μέσα στην τρέχουσα εβδομάδα (0–167), το week * 168 αποτελεί την μετατόπιση για τις προηγούμενες εβδομάδες. Για παράδειγμα h = 10 (Δευτέρα 10:00), week = 2 → hour = 10 + 2*168 = 346, δηλαδή η ίδια ώρα στη 3η εβδομάδα.
                    hourlySchedule.computeIfAbsent(hour, k -> new java.util.ArrayList<>()).add(c);		// Το hourlySchedule είναι ένα Map<Integer, List<Customer>>, όπου το key είναι η ώρα στο 6μηνο διάστημα (0–4367) και value είναι η λίστα πελατών που έχουν δρομολόγιο αυτήν την ώρα. Μέσω του computeIfAbsent(hour, k -> new ArrayList<>()), αν δεν υπάρχει ήδη λίστα για την ώρα hour, δημιουργείται τότε μια νέα ArrayList, ενώ εάν υπάρχει λίστα για την ώρα τότε χρησιμοποιείται η υπάρχουσα λίστα, καθώς μέσω της μεθόδου .add(c) πραγματοποιείται η προσθήκη του πελάτη c στη λίστα για αυτήν την ώρα. Πιο συγκεκριμένα μετατρέπονται οι εβδομαδιαίες ώρες δρομολογίων του κάθε πελάτη σε ένα πλήρες 6μηνο ωρολόγιο πρόγραμμα, ώστε αργότερα η προσομοίωση να ξέρει ποιοι πελάτες έχουν δρομολόγιο κάθε ώρα.
                }
            }
        }

        
        // Παρακάτω προσομειώνεται κάθε εργάσιμη ώρα ενός 6μήνου και επιλέγει κάθε φορά το οικονομικά βέλτιστο route, με πραγματικούς περιορισμούς φορτηγών, χωρητικότητας και πελατών.
        for (int hour = 0; hour < totalHours; hour++) {		// Στον επαναληπτικό αυτό βρόγχο διατρέχεται σε κάθε επανάληψη κάθε ώρα του 6μήνου, όπου το totalHours = 24 × 7 × 26 = 4368 ώρες, καθώς η μεταβλητή hour είναι ένας γραμμικός χρονικός άξονας, όπου το 0 αναπαριστά την αρχή της 1ης εβδομάδας, το 167 αναπαριστά το τέλος της 1ης εβδομάδας και το 168 αναπαριστά την αρχή της 2ης εβδομάδας. Ο ενιαίος χρονικός αυτός άξονας κάνει την προσωμοίωση πιο γρήγορη χωρίς nested ημερολόγια (ημέρα / εβδομάδα / μήνας).
            int hourOfDay = hour % 24;			// Σε αυτό το σημείο μετατρέπεται η ώρα σε ώρα ημέρας όπου λαμβάνεται η ώρα μέσα στην ημέρα (0-23), δηλαδή hour = 49 → 49 % 24 = 1 (01:00) ή hour = 82 → 82 % 24 = 10 (10:00).
            if (hourOfDay < 8 || hourOfDay >= 20) continue; 		// Σε αυτό το σημείο δημιουργείται ένα φίλτρο εργάσιμων ωρών, όπου εάν η ώρα είναι πριν τις 08:00 και μετά τις 20:00 παραλείπεται η ώρα, καθώς η προσομοίωση δεν θα τρέξει στην περίπτωση εκτός των ορίων, δηλαδή πριν τις 08:00 ή μετά τις 20:00, από την στιγμή που δεν επιτρέπονται δρομολόγια εκτός ωραρίου λειτουργίας της εταιρείας καθώς σε αυτή την περίπτωση δεν δημιουργείται τεχνητό κόστος/κέρδος.

            List<Customer> activeCustomers = hourlySchedule.get(hour);			// Σε αυτό το σημείο λαμβάνεται από το hourlySchedule ποιοι πελάτες έχουν trip αυτή την ώρα καθώς επιστρέφεται η λίστα ενεργών πελατών για αυτή την ώρα.
            if (activeCustomers == null || activeCustomers.isEmpty()) continue;		// Σε αυτό το σημείο αν κανένας πελάτης δεν έχει ζητήσει μεταφορά κάποιου προιόντος τότε δεν πραγματοποιείται εξέταση των routes και περνάει το πρόγραμμα στην επόμενη ώρα, βελτιστοποιώντας έτσι την απόδοση.

            // Παρακάτω με τις μεταβλητές αυτές γίνεται έλεγχος για το ποιο route (δρομολόγιο) μία συγκεκριμένη ημέρα την τρέχουσα ώρα δίνει το μεγαλύτερο κέρδος. Πιο συγκεκριμένα μέσα στο loop της κάθε ώρας για αυτή την 1 ώρα ο παρακάτω αλγόριθμος θα δοκιμάσει όλα τα routes, θα υπολογίσει κέρδος, κόστος, έσοδα και στο τέλος θα κρατήσει μόνο το καλύτερο route που έγινε αυτή την ώρα, καθώς αυτές οι μεταβλητές είναι η μνήμη της καλύτερης επιλογής, δηλαδή αποθηκεύουν την καλύτερη επιλογή. Οι μεταβλητές αυτές αφορούν μόνο την τρέχουσα ώρα, όχι όλο το 6μηνο, καθώς δεν αποθηκεύουν δεδομένα πολλών ωρών και δεν σχετίζονται με πελάτες απευθείας.
            // Η αρχιτεκτονική αυτή βασίζεται στο greedy optimization pattern ανά ώρα, καθώς κάθε ώρα θεωρείται ανεξάρτητο πρόβλημα και για κάθε route υπολογίζεται το profit, καθώς επιλέγεται το route με το μέγιστο κέρδος, όπου αν το μέγιστο κέρδος είναι ≤ 0 τότε δεν εκτελείται τίποτα, δηλαδή κανένα δρομολόγιο, εξασφαλίζοντας ότι δεν εκτελείται ζημιογόνο δρομολόγιο, διότι πάντα επιλέγεται η καλύτερη δυνατή επιλογή με τους τρέχοντες περιορισμούς. Αυτές οι μεταβλητές λειτουργούν σαν “πίνακας βαθμολογίας” για την τρέχουσα ώρα, κρατώντας την καλύτερη οικονομικά απόφαση που έχει βρεθεί μέχρι στιγμής.
            double bestProfit = Double.NEGATIVE_INFINITY;		// Σε μία μεταβλητή τύπου double (bestProfit), δίνεται μία αρχική τιμή, δηλαδή το -∞ (αρνητικό άπειρο), καθώς ένα route μπορεί να έχει αρνητικό κέρδος όμως θέλουμε η πρώτη έγκυρη λύση να γίνει αποδεκτή, διότι στην περίπτωση που έμπαινε η τιμή 0, δηλαδή routes με ζημία (π.χ. -50) δεν θα εξετάζονταν σωστά. Με το NEGATIVE_INFINITY το πρώτο route που θα εξεταστεί πάντα κερδίζει και μετά πραγματοποιείται σύγκριση σε όλα τα υπόλοιπα routes.
            int bestTrips = 0;		// Εδώ κρατιέται ο αριθμός των trips που απαιτεί ένα συγκεκριμένο route για το μέγιστο κέρδος, καθώς αρχικά έχει την τιμή 0, διότι δεν έχει επιλεγεί κανένα route.
            double bestRevenue = 0;		// Εδώ αποθηκεύονται τα έσοδα της διαδρομής που τελικά θα επιλεγεί ως το καλύτερο route, δηλαδή ως την καλύτερη διαδρομή με τα περισσότερα έσοδα, καθώς δεν υπολογίζεται ξανά μετά, απλώς προστίθεται στο συνολικό revenue.
            double bestCost = 0;		// Εδώ αποθηκεύεται το κόστος του route με το καλύτερο κέρδος και άρα το χαμηλότερο κόστος.

            // Ο παρακάτω κώδικας βάσει και των προηγούμενων σχολίων, εκτελείται για μία συγκεκριμένη ώρα, καθώς εξετάζει όλα τα διαθέσιμα routes για να βρει ποιο route αποφέρει το μεγαλύτερο κέρδος αυτή την ώρα, με βάση ποιοι πελάτες είναι ενεργοί, ποια αποθήκη χρησιμοποιούν, την χωρητικότητα και το πλήθος των φορτηγών καθώς και την απόσταση του δρομολογίου (route).
            for (String routeCode : routeDistances.keySet()) {		// Μέσω του επαναληπτικού βρόγχου for σε κάθε επανάληψη διατρέχονται όλα τα routes καθώς κάθε routeCode είναι ένα πιθανό δρομολόγιο που μπορεί να εκτελεστεί αυτή την ώρα.
                List<Customer> customersOnRoute = activeCustomers.stream()		// Σε αυτό το σημείο λαμβάνεται η λίστα activeCustomers, δηλαδή οι πελάτες για τους οποίους υπάρχει δρομολόγιο αυτή την ώρα, ενώ ταυτόχρονα μετατρέπεται η λίστα σε Stream για λειτουργικό φιλτράρισμα. Η activeCustomers είναι μια List<Customer> στη μνήμη, όπου μέσω του .stream() δεν αντιγράφονται δεδομένα, δημιουργείται ένα Stream pipeline επιτρέποντας διαδοχικούς μετασχηματισμούς.
                        .filter(c -> c.warehouseType.equalsIgnoreCase(warehouseType))		// Εδώ διατηρούνται μόνο οι πελάτες που εξυπηρετούνται από τον τύπο αποθήκης που τρέχει το simulation (SHORT ή LONG), καθώς στην περίπτωση που το simulation τρέχει για πελάτες που εξυπηρετούνται από short_term αποθήκη τότε αγνοούνται όλοι οι πελάτες που εξυπηρετούνται από long_term τύπο αποθήκης. Εδώ στην ουσία σε κάθε επανάληψη για κάθε Customer αντικείμενο καλείται το c.warehouseType όπου συγκρίνεται με το warehouseType του simulation καθώς αν επιστρέψει true ο πελάτης περνά στο επόμενο στάδιο ενώ αν επιστρέψει false o πελάτης απορρίπτεται από το stream.
                        .filter(c -> RouteDAO.getRouteStops(routeCode).contains(c.city))	// Σε αυτό το σημείο πραγματοποιείται ένα φίλτρο όπου μέσω του RouteDAO.getRouteStops(routeCode), επιστρέφονται οι πόλεις με τις ενδιάμεσες στάσεις (stops) όπου περνά το συγκεκριμένο δρομολόγιο, καθώς μέσω του contains(c.city) ελέγχεται εάν ο πελάτης βρίσκεται πάνω στο συγκεκριμένο route, με αποτέλεσμα να διατηρούνται μόνο οι ενεργοί πελάτες που έχουν σωστό warehouse και βρίσκονται σε πόλη που περνά το route (το δρομολόγιο).
                        .toList();			// Σε αυτό το σημείο το αποτέλεσμα του stream μετατρέπεται ξανά σε List<Customer>, όπου λόγω χρήσης του customersOnRoute που θα επεξηγηθεί στην συνέχεια, αναπαριστά τους πελάτες που μπορούν να εξυπηρετηθούν από αυτό το route αυτή την ώρα. Πιο συγκεκριμένα το stream εκτελείται τώρα δημιουργώντας μία καινούρια List<Customer>, που περιέχει μόνο τους πελάτες που είναι ενεργοί, ανήκουν στο σωστό warehouse και βρίσκονται πάνω στο συγκεκριμένο route, καθώς αυτή η λίστα customersOnRoute(=>Το σύνολο των πελατών που μπορούν ρεαλιστικά να εξυπηρετηθούν από αυτό το route σε αυτή τη συγκεκριμένη ώρα και δεν είναι όλοι οι πελάτες, δεν είναι όλοι οι πελάτες του route και ούτε όλοι οι ενεργοί πελάτες) είναι απολύτως κρίσιμη για τους επόμενους υπολογισμούς, καθώς κάθε route αξιολογείται μόνο με τα δεδομένα που πραγματικά το αφορούν. Στην ουσία για κάθε πιθανό δρομολόγιο, λαμβάνονται οι πελάτες που έχουν ανάγκη μεταφοράς αυτή την ώρα, καθώς κρατάω μόνο όσους εξυπηρετούνται από το warehouse που εξετάζω και βρίσκονται σε πόλη που περνά το δρομολόγιο, και με αυτούς υπολογίζω αν αξίζει να εκτελεστεί το δρομολόγιο(route).

                int routeVolume = customersOnRoute.stream()		// Σε αυτό το σημείο δημιουργείται ένα stream από το customersOnRoute, όπου για κάθε Customer c λαμβάνεται το c.volumePerTrip, όπου στην ουσία αθροίζονται όλες οι ποσότητες, καθώς το routeVolume ισοδυναμεί με τον συνολικό όγκο ενός φορτίου, δηλαδή αυτό σημαίνει επιχειρησιακά πόσο φορτίο (π.χ. παλέτες / κιλά / μονάδες) πρέπει να μεταφερθεί αν εκτελεστεί αυτό το route αυτή την ώρα. Μέσω του customersOnRoute.stream() μετατρέπεται η λίστα σε Stream API, όπου λόγω του .mapToInt(c -> c.volumePerTrip) για κάθε Customer εξάγεται ένας ακέραιος αριθμός και μέσω του .sum() αθροίζονται όλοι οι ακέραιοι επιστρέφοντας έναν αριθμό int, καθώς αυτό υλοποιεί την λογική ότι αν εκτελεστεί αυτό το route αυτή την ώρα καθορίζεται πόσο φορτίο πρέπει να μεταφερθεί συνολικά. Στην ουσία κάθε πελάτης έχει ένα volumePerTrip (όγκο μεταφοράς του προιόντος που πρέπει να του μεταφερθεί), όπου αν όλοι οι πελάτες είναι πάνω στο ίδιο route, τότε όλα τα φορτία συνδυάζονται με αποτέλεσμα να προκύπτει το ζητούμενο φορτίο της ώρας. 
                        .mapToInt(c -> c.volumePerTrip)
                        .sum();

                if (routeVolume == 0) continue;		// Στην περίπτωση που δεν υπάρχει φορτίο προς μεταφορά για κάποιον πελάτη δεν έχει νόημα να υπολογιστεί το δρομολόγιο (route), με αποτέλεσμα να περνάμε στο επόμενο δρομολόγιο (route), καθώς αυτό είναι πολύ σημαντικό να διεκπαιρεωθεί στην περίπτωση αποφυγής δρομολογίων (trips = 0) με μεγάλο κόστος > 0. Σε αυτό το σημείο πραγματοποιείται η μετάβαση στο επόμενο routeCode (μέσω της εντολής continue), καθώς δεν εξετάζεται route που δεν έχει κάποιον όγκο μεταφοράς, διότι αν υπάρχει δρομολόγιο χωρίς να έχει κάποιο φορτίο το φορτηγό, που σημαίνει ότι μόνο κόστος θα έχει και καθόλου έσοδα, τότε δεν εκτελείται το δρομολόγιο.

                int trips = (int) Math.ceil((double) routeVolume / truck.getCapacity());		// Σε αυτό το σημείο διαιρείται ο συνολικός όγκος με τη χωρητικότητα του φορτηγού, ενώ μέσω χρήσης του Math.ceil πραγματοποιείται στρογγυλοποίηση προς τα πάνω, δηλαδή για παράδειγμα εάν ο όγκος = 25 και η χωρητικότητα = 10 τότε trips = ceil(2.5) = 3. Αυτό επειχηρισιακά σημαίνει ότι δεν θα εκτελεστεί μισό δρομολόγιο από την στιγμή που χρειάζεται ένα ολόκληρο φορτηγό να είναι τέρμα γεμάτο το φορτηγό για να εκτελεστεί το δρομολόγιο. Μέσω αυτού του υπολογισμού εξάγεται ως συμπέρασμα η λογική του ότι πόσα δρομολόγια χρειάζονται για να μεταφερθεί όλο το φορτίο προς τους πελάτες. Στην ουσία μεαυτόν τον τρόπο ελέγχεται η χωρητικότητα του φορτηγού, καθώς αν περισέψει φορτίο απαιτείται επιπλέον trip.
                trips = Math.min(trips, truck.getQuantity());		// Σε αυτό το σημείο πραγματοποιείται περιορισμός από το πλήθος των διαθέσιμων φορτηγών, όπου στην περίπτωση που χρειάζονται 5 διαδρομές (trips) να γίνουν, αλλά υπάρχει διαθεσιμότητα μόνο για 3 φορτηγά τότε εκτελούνται μόνο τα 3 δρομολόγια από τα 5 εισάγοντας πραγματικό περιορισμό πόρων στο συγκεκριμένο μοντέλο. 

                double distance = routeDistances.get(routeCode);		// Εδώ πραγματοποιείται ανάκτηση της απόστασης του route μέσω της μεθόδου get(key), όπου επιστρέφεται η τιμή του στοιχείου δεδομένων, προσδιοριζόμενο από την τιμή του συγκεκριμένου κλειδιού, καθώς στην συνέχεια όλοι οι οικονομικοί υπολογισμοί που θα διεξαχθούν εξαρτώνται από αυτή την απόσταση, η οποία απόσταση επηρρεάζει τα καύσιμα, τον χρόνο και τα έσοδα.
                double revenue = (10.0 * routeVolume * distance) / 100.0;		// Σε αυτό το σημείο πραγματοποιείται ένας υπολογισμός εσόδων, όπου σύμφωνα με την τιμολογιακή πολιτική €10 ανά μονάδα φορτίου ανά 100 χιλιόμετρα, ανάγεται το συμπέρασμα ότι όσο περισσότερο φορτίο υπάρχει στην χωρητικότητα ενός φορτηγού (να είναι πλήρως γεμάτο σε φορτίο το φορτηγό μέχρι όσο χωράει δηλαδή βάσει της χωρητικότητας που δέχεται ο κάθε τύπος φορτηγού) και όσο μεγαλύτερη απόσταση καλύπτει ένα φορτηγό, τόσο περισσότερα είναι τα έσοδα που θα προκύψουν.
                double cost = (10.0 * distance * trips) / 100.0;		// Σε αυτό το σημείο υπολογίζεται το κόστος ανά δρομολόγιο (trip), καθώς εξαρτάται μόνο από την απόσταση και από τον αριθμό των trips, από την στιγμή που το κόστος δεν εξαρτάται από το φορτίο κι άρα συμφέρει επιχειρησιακά την εταιρεία να γεμίζει το φορτηγό μέχρι όσο χωράει η χωρητικότητα του κάθε τύπου φορτηγού.
                double profit = revenue - cost;		// Κι εδώ υπολογίζεται το καθαρό κέρδος του route.

                if (profit > bestProfit) {		// Σε αυτό το σημείο συγκρίνεται το τρέχον route με το καλύτερο route (δρομολόγιο) μέχρι τώρα, καθώς αν βρεθεί καλύτερο από άποψη κέρδους route από αυτό που ήδη υπάρχει τότε αντικαθίσταται το καλύτερο δρομολόγιο (route) που βρέθηκε για την συγκεκριμένη ώρα υλοποιώντας το επιχειρησιακό μοντέλο greedy optimization ανά ώρα, δηλαδή βελτιστοποίηση του κέρδους ανά ώρα σύμφωνα με το καλύτερο route που έχει προκύψει για αυτή την ώρα.
                    bestProfit = profit;
                    bestTrips = trips;
                    bestRevenue = revenue;
                    bestCost = cost;
                }
            }

            if (bestProfit > 0) {		// Σε αυτό το σημείο ελέγχεται η περίπτωση όπου εάν το καλύτερο route βγάζει ζημία τότε δεν εκτελείται το δρομολόγιο.
                totalTrips += bestTrips;
                totalRevenue += bestRevenue;
                totalCost += bestCost;
            }
        }

        double totalProfit = totalRevenue - totalCost;		// Σε αυτό το σημείο υπολογίζεται το τελικό καθαρό κέρδος 6μήνου. Το καθαρό οικονομικό αποτέλεσμα όλων των ωρών όλων των ημερών των 6 μηνών.

        // Δημιουργία αποτελεσμάτων ως String.
        StringBuilder sb = new StringBuilder();		// Σε αυτό το σημείο δημιουργείται ένα αντικείμενο StringBuilder, καθώς δεσμεύεται χώρος στη μνήμη (heap), ενώ η μεταβλητή sb κρατά το reference, δηλαδή την αναφορά σε αυτό το αντικείμενο, καθώς το εσωτερικό του buffer είναι κενό. Στην ουσία μέσω του StringBuilder υπάρχει η δυνατότητα αντικείμενα της κλάσης String (αλφαριθμητικά) να αλλάξουν με δυναμικό τρόπο μέσα στο ίδιο αντικείμενο, καθώς η κλάση StringBuilder ανήκει στο πακέτο java.lang που είναι ήδη imported ως πακέτο και δεν χρειάζεται να γίνει κάποιο import.
        sb.append(stochastic ? "🎲 STOCHASTIC OPTIMIZED SIMULATION (6 months)\n\n" :		// Σε αυτό το σημείο η μέθοδος append() προσθέτει το όρισμα το οποίο περιέχει στο αντικείμενο StringBuilder, όπου η JVM διαβάζει την boolean τιμή (stochastic) κι αν η τιμή αυτής της μεταβλητής είναι true τότε επιλέγεται μέσω του τριαδικού τελεστή το πρώτο String (stochastic simulation), ενώ αν η τιμή είναι false τότε επιλέγεται το δεύτερο String (deterministic simulation), όπου στην ουσία το επιλεγμένο String αντιγράφεται στον buffer του StringBuilder.
                               "⏱ DETERMINISTIC HOURLY SIMULATION (6 months)\n\n");
        sb.append("Warehouse Type: " + warehouseType + "\n");		// Σε αυτό το σημείο πραγματοποιείται η προσθήκη του τύπου της αποθήκης (Warehouse Type), όπου δημιουργείται ένα προσωρινό String ("Warehouse Type: " + warehouseType + "\n"), καθώς αυτό το string προστίθεται στο τέλος του buffer και προκύπτει αυτό εδώ (Warehouse Type: SHORT).
        sb.append("Truck Type: " + truck.getCategory() + "\n");		// Σε αυτό το σημείο πραγματοποιείται η προσθήκη του τύπου του φορτηγού, όπου στην ουσία καλείται το (truck.getCategory()) κι επιστρέφει για παράδειγμα την τιμή "MEDIUM" δημιουργώντας αυτό εδώ το string ("Truck Type: MEDIUM\n"), το οποίο προστίθεται στο τέλος. Στην ουσία λαμβάνεται το category του φορτηγού (π.χ. SMALL, MEDIUM, LARGE) και ενσωματώνεται στο report, καθώς το SimulationEngine δεν γνωρίζει τα εσωτερικά του Truck χρησιμοποιώντας μόνο public API (getCategory()), βάσει της Encapsulation.
        sb.append("Total Trips: " + totalTrips + "\n");				// Εδώ προστίθενται οι συνολικές διαδρομές όπου αυτό εδώ για παράδειγμα (Total Trips: 142), μετατρέπεται αυτόματα σε String και προστίθεται στο report. Στην ουσία καταμετράται το πλήθος δρομολογίων που εκτελέστηκαν τελικά (όχι όσα ζητήθηκαν) αλλά όσα ήταν κερδοφόρα για να εκτελεστούν.
        sb.append("Total Revenue: " + String.format("%.2f", totalRevenue) + " €\n");	// Προσθήκη εσόδων με μορφοποίηση, όπου στην ουσία δημιουργείται αυτό εδώ το string ("Total Revenue: 12345.68 €\n") και προστίθεται στο τέλος.
        sb.append("Total Cost: " + String.format("%.2f", totalCost) + " €\n");		// Εδώ πραγματοποιείται η προσθήκη του κόστους με ακριβώς ίδια διαδικασία με το Revenue.
        sb.append("Total Profit: " + String.format("%.2f", totalProfit) + " €\n");		// Προσθήκη του κέρδους με ίδια διαδικασία όπως και παραπάνω, όπου αυτό είναι το τελικό αποτέλεσμα της προσωμοίωσης.

        return sb.toString();		// Εδώ επιστρέφεται το τελικό String, όπου ο StringBuilder μετατρέπεται σε immutable String και δημιουργείται ένα νέο αντικείμενο String. Στην ουσία το UI δεν χρειάζεται το StringBuilder, διότι χρειάζεται μόνο την εμφάνιση του τελικού report.
    }

    
    // Υπολογίζει το συνολικό κέρδος για συγκεκριμένο route χωρίς hourly simulation. Στην ουσία σε αυτή την μέθοδο προσδιορίζουμε ποιοι πελάτες θα εξυπηρετηθούν αυτό το route, ώστε να υπολογίσουμε τον όγκο και τα έσοδα που θα προκύψουν μόνο για αυτούς τους πελάτες.
    // Η μέθοδος αυτή φιλτράρει πελάτες που ανήκουν στον τύπο αποθήκης και είναι στο route, υπολογίζει τον συνολικό όγκο φορτίου ανά εβδομάδα, υπολογίζει πόσα trips χρειάζονται για το φορτίο, υπολογίζει εβδομαδιαία έσοδα και κόστος και τέλος επιστρέφει το κέρδος για 26 εβδομάδες (6 μήνες).
    public double calculateProfitForRoute(String routeCode) {		// Μέσω της public αυτής μεθόδου λαμβάνεται ως είσοδος το routeCode (π.χ. “R1”) και επιστρέφεται το συνολικό κέρδος για αυτό το route, καθώς σε αυτή την μέθοδο δεν τρέχει simulation ανά ώρα (hourly simulation), αλλά υπολογίζει καθαρά τα κέρδη βάσει εβδομαδιαίων εκτιμήσεων πολλαπλασιασμένων επί 26 εβδομάδων που είναι δηλαδή οι (6 μήνες).
        List<Customer> customersOnRoute = customers.stream()		// Σε αυτό το σημείο λαμβάνεται η λίστα όλων των customers, καθώς (υπάρχει σαν πεδίο της κλάσης SimulationEngine), όπου δημιουργείται ένα stream() για το φιλτράρισμα των πελατών. Το πρώτο φίλτρο είναι: c.warehouseType.equalsIgnoreCase(warehouseType), το οποίο κρατά μόνο τους πελάτες που εξυπηρετούνται από τον τύπο αποθήκης που τρέχει το simulation (SHORT ή LONG term αποθήκη). Το δεύτερο φίλτρο: RouteDAO.getRouteStops(routeCode).contains(c.city), διατηρεί μόνο τους πελάτες που βρίσκονται σε πόλεις που καλύπτει το συγκεκριμένο route (δρομολόγιο).
                .filter(c -> c.warehouseType.equalsIgnoreCase(warehouseType))
                .filter(c -> RouteDAO.getRouteStops(routeCode).contains(c.city))
                .toList();		// Σε αυτό το σημείο επιστρέφεται η φιλτραρισμένη λίστα ως List<Customer>.

        int totalWeeklyVolume = customersOnRoute.stream()		// Σε αυτό το σημείο για κάθε πελάτη που βρίσκεται στο route υπολογίζεται ο εβδομαδιαίος όγκος: volumePerTrip * weeklyTrips, καθώς το (mapToInt) μετατρέπει το stream σε ακέραιες τιμές (int) και το sum() αθροίζει όλους τους όγκους για να έχουμε συνολικό εβδομαδιαίο όγκο φορτίου για αυτό το route. Στην ουσία εδώ ο συνολικός όγκος ανά εβδομάδα χρησιμοποιείται για να καθοριστεί πόσα trips χρειάζονται και ποιο είναι το έσοδο που θα προκύψει.
                .mapToInt(c -> c.volumePerTrip * c.weeklyTrips)
                .sum();

        int tripsPerWeek = (int) Math.ceil((double) totalWeeklyVolume / truck.getCapacity());		// Σε αυτό το σημείο υπολογίζουμε πόσα ταξίδια χρειάζονται για να μεταφέρουμε όλο τον εβδομαδιαίο όγκο, καθώς το truck.getCapacity() αοτελεί την χωρητικότητα ενός φορτηγού, όπου διαιρείται το totalWeeklyVolume / truck.getCapacity() και υπολογίζονται πόσα trips χρειάζονται, διότι μέσω του Math.ceil(...) στρογγυλοποιεί προς τα πάνω (π.χ. αν χρειάζονται 2.3 trips το αποτέλεσμα είναι ότι χρειάζονται 3 trips/δρομολόγια) ενω ταυτόχρονα μετατρέπεται σε int, διότι δεν είναι λογικό να έχουμε δεκαδικό αριθμό ή κλάσμα για την αναπαράσταση και τον υπολογισμό του αριθμού ενός δρομολογίου. Στην ουσία απαιτείται να υπολογίσουμε πλήρη ταξίδια για να μεταφερθεί όλο το φορτίο, χωρίς να αφήσουμε αχρησιμοποίητο φορτίο.
        double tripRevenue = (10.0 * totalWeeklyVolume * routeDistances.get(routeCode)) / 100.0;	// Σε αυτό το σημείο υπολογίζουμε τα έσοδα (revenue) για ένα εβδομαδιαίο σύνολο trips (δρομολογίων), σύμφωνα με την τιμολογιακή πολιτική €10 ανά μονάδα φορτίου ανά 100 χιλιόμετρα, όπου μέσω του routeDistances.get(routeCode) υπολογίζεται η απόσταση του route σε χιλιόμετρα ενώ ταυτόχρονα διαιρείται /100.0 για την μετατροπή στη σωστή αναλογία ανά 100 km. Στην ουσία όσο μεγαλύτερος ο όγκος ή η απόσταση, τόσο μεγαλύτερα είναι τα έσοδα, καθώς εδώ δεν λαμβάνεται υπόψη η χωρητικότητα των φορτηγών, γιατί έχει ήδη υπολογιστεί στα trips.
        double tripCost = ((10.0 * routeDistances.get(routeCode)) / 100.0) * tripsPerWeek;		// Εδώ υπολογίζουμε το κόστος για την εκτέλεση των trips αυτής της εβδομάδας, καθώς το κόστος ανά trip = €10 ανά 100 km, όπου πολλαπλασιάζεται με tripsPerWeek για να έχουμε συνολικό κόστος μεταφοράς. Η λογική είναι εδώ ότι παράλληλα με τα έσοδα, χρειάζεται να υπολογίσουμε το κόστος μεταφοράς για να έχουμε καθαρό κέρδος.

        return (tripRevenue - tripCost) * 26; 		// Εδώ υπολογίζουμε το καθαρό κέρδος ανά εβδομάδα: tripRevenue - tripCost, όπου πολλαπλασιάζουμε επί 26 εβδομάδες, που αντιστοιχούν στους 6 μήνες και εδώ στην ουσία καλύπτουμε τους 6 μήνες, από την στιγμή που επιστρέφεται ως αποτέλεσμα της μεθόδου calculateProfitForRoute. Πιο συγκεκριμένα εδώ αντί να τρέξουμε full hourly simulation, μπορούμε γρήγορα να υπολογίσουμε το προβλεπόμενο 6μηνιαίο κέρδος με βάση τα εβδομαδιαία δεδομένα.
    }		// εδώ κλείνει η μέθοδος.


    public Map<String, Double> calculateProfitForAllRoutes() {		// Η μέθοδος αυτή υπολογίζει το κέρδος για όλα τα routes ταυτόχρονα, καθώς είναι public και μπορεί να κληθεί από το GUI, επιστρέφει ένα Map<String, Double>, όπου το Key (String) αντιπροσωπεύει το routeCode (π.χ. "R1", "R2") και το Value (Double) αντιπροσωπεύει το συνολικό κέρδος 6μήνου για το route. Δεν δέχεται παραμέτρους, γιατί χρησιμοποιεί τα πεδία της κλάσης (customers, routeDistances, truck, warehouseType), από την στιγμή που δουλεύει πάνω στο state του SimulationEngine. Η μέθοδος αυτή είναι μία instance μέθοδος, όπου επιστρέφει μία αναφορά (reference) σε αντικείμενο τύπου Map<String, Double>, καθώς το this της μεθόδου δείχνει σε ένα συγκεκριμένο αντικείμενο SimulationEngine, αφού επιστρέφει ένα Map<String, Double> όπου συνδέεται route → profit. Έχει επιλεχθεί το Map ως σωστή δομή δεδομένων γιατί κάθε route έχει ένα μοναδικό κλειδί, η πρόσβαση είναι O(1) και το GUI μπορεί να κάνει iterate ή lookup σύμφωνα με τις αρχές του Encapsulation και του Service Object pattern.
        Map<String, Double> profits = new HashMap<>();		// Εδώ δημιουργείται ένα άδειο HashMap στο heap, το οποίο αποθηκεύει routeCode → profit, όπου η μεταβλητή profits κρατά reference σε αυτό το αντικείμενο για αποθήκευση και ανάγνωση.

        for (String routeCode : routeDistances.keySet()) {		// Σε κάθε επανάληψη και για όλα τα routes το routeDistances είναι Map<String, Double> routeDistances, όπου μέσω του routeDistances.keySet() επιστρέφονται όλοι οι κωδικοί των routes (διαδρομών), καθώς η επαναληπτική δομή θα τρέξει 1 φορά για κάθε route (διαδρομή). Μέσω του keySet() επιστρέφεται ένα Set<String>, καθώς δεν αντιγράφει δεδομένα, διότι αποτελέι ένα view πάνω στο Map.
            profits.put(routeCode, calculateProfitForRoute(routeCode));		// Σε αυτό το σημείο υπολογίζεται το κέρδος ανά route, όπου για κάθε routeCode καλείται η calculateProfitForRoute(routeCode), η οποία φιλτράρει τους πελάτες, υπολογίζει τον εβδομαδιαίο όγκο, υπολογίζει τα trips, υπολογίζει έσοδα – κόστος, πολλαπλασιάζει × 26 εβδομάδες, ενώ το αποτέλεσμα αποθηκεύεται στο Map ως profits.put("R1", 12500.75). Στην ουσία αποθηκεύεται το τελικό 6μηνιαίο κέρδος για κάθε route. Σε αυτό το σημείο υπολογίζεται και αποθηκεύεται το κέρδος για όλα τα routes, όπου εντός του Map το routeCode είναι το identifier, το profit είναι το business αποτέλεσμα και όλα αυτά αποθηκεύονται ως immutable (δεν μπορούν να αλλάξουν μετά) Double, καθώς το Map δεν γνωρίζει πώς έγινε ο υπολογισμός του κέρδους απλά γνωστοποιεί μόνο τί είναι το αποτέλεσμα.
        }	// Όλα τα routes έχουν υπολογιστεί και το Map είναι πλήρες.

        return profits;		// Επιστρέφεται ολόκληρος ο πίνακας κερδών, δηλαδή επιστρέφονται όλα τα routes με το αντίστοιχο κέρδος τους. Στην ουσία επιστρέφεται μία αναφορά (reference) στο Map (όχι αντίγραφο, όχι πρωταρχικός τύπος δεδομένου), διότι με αυτόν τον τρόπο το GUI μπορεί να το εμφανίσει, να το ταξινομήσει, να το φιλτράρει και να βρει την καλύτερη διαδρομή.
    }	// εδώ κλείνει η μέθοδος.
}	// εδώ κλείνει η κλάση SimulationEngine.
