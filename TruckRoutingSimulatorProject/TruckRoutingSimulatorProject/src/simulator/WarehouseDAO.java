package simulator;		// Όλες οι κλάσεις DAO (CustomerDAO, RouteDAO, TruckDAO, WarehouseDAO) είναι στο ίδιο πακέτο.

import java.sql.*;		// Εισαγωγή όλου του JDBC API (Connection, PreparedStatement, ResultSet, SQLException) για επικοινωνία με την βάση δεδομένων.
import java.util.ArrayList;		// Εισαγωγή της συγκεκριμένης υλοποίησης.
import java.util.List;		// Εισαγωγή του interface.

public class WarehouseDAO {		// Δημιουργία αυτής της DAO κλάσης για πρόσβαση και διαχείριση των δεδομένων από την βάση.

    
    public static List<String> getWarehousesByType(String type) {	// Μέσω δημιουργίας αυτής της public μεθόδου (ορατή σε όλη την εφαρμογή), δεν απαιτείται η δημιουργία αντικειμένου για χρήση κι εκτέλεση της μεθόδου αυτής, καθώς επιστρέφεται η λίστα αποθηκών θέτοντας όμως ως φίλτρο τον τύπο που είναι η κάθε αποθήκη (short ή long term). 
        List<String> warehouses = new ArrayList<>();		// Σε αυτό το σημείο δημιουργείται η λίστα των αποτελεσμάτων, όπου δημιουργείται μία κενή λίστα καθώς αυτή η λίστα θα γεμίσει δυναμικά από την βάση δεδομένων, καθώς εάν δεν βρεθούν αποθήκες επιστρέφεται μία κενή λίστα. Το warehouses είναι μια λίστα από String, όπου κάθε στοιχείο της λίστας αντιπροσωπεύει μία αποθήκη, καθώς δεν αποθηκεύονται αντικείμενα Warehouse αλλά αποθηκεύεται μορφοποιημένη πληροφορία (id + πόλη), δηλαδή το id της κάθε αποθήκης και η πόλη στην οποία βρίσκεται η κάθε αποθήκη.

        // Παρακάτω δημιουργείται ένα sql query ως String κι εκχωρείται μέσα στην μεταβλητή sql, καθώς θα εκτελεστεί μέσω του PreparedStatement με παραμέτρους που δίνονται αργότερα.
        String sql = "SELECT warehouse_id, city_name FROM warehouses " +	// Ανάκτηση του warehouse_id και του city_name από τον πίνακα warehouses, ενώ μέσω του WHERE ανακτώνται οι αποθήκες, όπου αν η παράμετρος είναι 'SHORT' και υπάρχει short_term_capacity > 0 τότε ανακτά από την βάση δεδομένων αυτές τις αποθήκες. Ενώ εάν η παράμετρος είναι 'LONG' και υπάρχει long_term_capacity > 0, τότε ανακτώνται από την βάση δεδομένων αυτός ο τύπος αποθηκών.
                     "WHERE (? = 'SHORT' AND short_term_capacity > 0) " +		// Μέσω του φίλτρου WHERE επιτρέπεται στο ίδιο query να επιστρέφει είτε short-term είτε long-term αποθήκες, ανάλογα με την τιμή που θα δοθεί στα placeholders (?) μέσω χρήσης του PreparedStatement.
                     "OR (? = 'LONG' AND long_term_capacity > 0)";

        try (Connection conn = DBConnection.getConnection();  	// Εδώ καλείται η μέθοδος DBConnection.getConnection(), όπου δημιουργείται πραγματική σύνδεση με τη βάση δεδομένων (MySQL), καθώς το αντικείμενο conn είναι τύπου java.sql.Connection, αποτελώντας ένα κανάλι επικοινωνίας” Java ↔ Database. Όταν τελειώσει το try μπλοκ τότε το conn.close() θα κληθεί αυτόματα.
             PreparedStatement ps = conn.prepareStatement(sql)) {		// Από το Connection δημιουργείται ένα PreparedStatement, καθώς αυτό το sql query => SELECT ...WHERE (? = 'SHORT' ...), προ-μεταγλωττίζεται από τη βάση.

        	// Οι αντικαταστάσεις των placeholders (?) και οι αναθέσεις τιμών επιτρέπουν στο SQL να αποφασίσει μόνο του ποιο φίλτρο θα ισχύσει ανάλογα με τον έλεγχο των συνθηκών που διατυπώθηκαν στο sql ερώτημα short_term_capacity > 0 ή long_term_capacity > 0.
            ps.setString(1, type);		// Εδώ αντικαθίσταται το πρώτο ? με την τιμή του type για short term αποθήκες.
            ps.setString(2, type);		// Κι εδώ αντικαθίσταται το δέυτερο ? με την τιμή του type για long term αποθήκες.

            try (ResultSet rs = ps.executeQuery()) {		// Εδώ πραγματοποιείται εκτέλεση του sql ερωτήματος ως προς την βάση επιστρέφοντας τον πίνακα αποτελεσμάτων εντός του ResultSet.
                while (rs.next()) {		// Εντός του επαναληπτικού βρόγχου while και σε κάθε επανάληψη μετακινείται ο κέρσορας (cursor) στην επόμενη γραμμή, καθώς χωρίς το rs.next() δεν είναι εφικτή η ανάγνωση των δεδομένων. Το ResultSet rs είναι ο πίνακας αποτελεσμάτων που επέστρεψε η βάση, καθώς ο cursor βρίσκεται στην τρέχουσα γραμμή, η οποία αντιστοιχεί σε μία αποθήκη, από την στιγμή που κάθε επανάληψη του while (rs.next()) = μία γραμμή SQL.
                    warehouses.add(rs.getInt("warehouse_id") + ": " + rs.getString("city_name"));		// Από την τρέχουσα γραμμή ανακτάται η τιμή της στήλης warehouse_id (αναγνωριστικό αποθήκης), καθώς και το όνομα της πόλης που βρίσκεται η συγκεκριμένη αποθήκη (city_name), ενώ μέσω του τελεστή (+)=>(String concatenation) μετατρέπεται αυτόματα το int σε String και στην συνέχεια δημιουργείται ένα καινούργιο αντικείμενο String στη μνήμη, αφού δημιουργείται runtime, δηλαδή κατά την εκτέλεση του simulation (πχ. "5: Θεσσαλονίκη"), όπου αυτό το καινούργιο string που προέκυψε προστίθεται στο τέλος της λίστας warehouses. Στην ουσία εδώ διαβάζεται το warehouse_id και το city_name από την τρέχουσα γραμμή του ResultSet, τα μετατρέπει σε ένα ενιαίο String μορφής "id: πόλη" και το αποθηκεύει στη λίστα αποτελεσμάτων.
                }
            }

        } catch (SQLException e) {		// Πιάνονται σφάλματα SQL σύνταξης, σύνδεσης, PreparedStatement, ResultSet και εκτύπωση των σφαλμάτων στην κονσόλα για debugging.
            e.printStackTrace();
        }

        return warehouses;		// Με την εντολή return τερματίζεται η εκτέλεση της μεθόδου άμεσα, καθώς εδώ επιστρέφεται η αναφορά (reference) στο αντικείμενο ArrayList (πχ. List<String> result = WarehouseDAO.getWarehousesByType("SHORT");), όπου στην ουσία εδώ δείχνει στο ίδιο ArrayList που δημιουργήθηκε μέσα στο DAO. Στην ουσία αν υπάρχουν αποθήκες επιστρέφεται η λίστα αποθηκών με τα στοιχεία της κάθε αποθήκης, αν δεν υπάρχουν αποθήκες επιστρέφεται κενή λίστα όπως κι αν υπάρξει SQL error επιστρέφεται πάλι κενή λίστα αποφεύγοντας με αυτόν τον τρόπο NullPointerException. Επομένως το return warehouses; τερματίζει τη μέθοδο και επιστρέφει την αναφορά της λίστας που περιέχει τις αποθήκες που πληρούν το κριτήριο, επιτρέποντας στο υπόλοιπο σύστημα να χρησιμοποιήσει τα δεδομένα χωρίς να γνωρίζει τίποτα για SQL ή JDBC.
    }
}	// εδώ κλείνει η κλάση WarehouseDAO.
