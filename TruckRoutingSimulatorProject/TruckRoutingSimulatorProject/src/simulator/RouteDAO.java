package simulator;

import java.sql.*;		// Εισαγωγή όλων των JDBC κλάσεων(Connection, Statement, PreparedStatement, ResultSet, SQLException) για πρόσβαση στη βάση δεδομένων MySQL.
import java.util.*;		// Εισαγωγή αυτού του πακέτου που περιέχει κλάσεις όπως Map, HashMap, List, ArrayList και Collections, που χρησιμοποιούνται για αποθήκευση και επεξεργασία δεδομένων.

public class RouteDAO {		// Η κλάση αυτή ακολουθεί το DAO pattern διαχωρίζοντας την διαχείρηση δεδομένων των routes από την υπόλοιπη εφαρμογή καθώς όλη η πρόσβαση στην βάση γίνεται σε αυτό το σημείο. 

    // Παρακάτω μία απεικόνιση (Map), είναι ένας τρόπος αποθήκευσης στοιχείων, όπου κάθε στοιχείο αποτελείται από ένα ζευγάρι κλειδιού τιμής καθώς σε αντίθεση με τους πίνακες, στην απεικόνιση κάθε στοιχείο συνδέεται με ένα κλειδί όπου με αυτόν τον τρόπο καθορίζεται η θέση αποθήκευσής του. Αυτό έχει ως αποτέλεσμα στον χάρτη απεικόνισης να αποθηκεύονται το κλειδί και η αντίστοιχη τιμή καθώς όταν είναι γνωστό το κλειδί αυτό έχει ως απόρροια να οδηγηθούμε στην αντίστοιχη τιμή, διευκρινίζοντας ότι δεν υπάρχουν διπλότυπα κλειδιά και κάθε κλειδί οδηγεί σε μία τιμή.
	// Μέσω του κατασκευαστή HashMap δημιουργείται ένα άδειο αντικείμενο HashMap με τους συγκεκριμένους τύπους για τα κλειδιά και τις τιμές.
	// Παρακάτω στο πεδίο δημιουργείται ένα νέο αντικείμενο στην heap memory δεσμεύοντας τον αντίστοιχο χώρο μνήμης, από την στιγμή που δημιουργείται ένα αντικείμενο τύπου HashMap καθώς η αναφορά αυτού του αντικειμένου αποθηκεύεται στη μεταβλητή routeStopsCache. Πιο συγκεκριμένα το HashMap υλοποιεί την διεπαφή Map<K, V>, καθώς ο πραγματικός πίνακας δημιουργείται όταν μπει το πρώτο στοιχείο ενώ μέσω χρήσης του <> ο compiler εξάγει αυτόματα τους τύπους.
	private static Map<String, List<String>> routeStopsCache = new HashMap<>();		// Πιο συγκεκριμένα το πεδίο αυτό προσδιορίζεται ως private, καθώς μπορεί να προσπελαστεί μόνο μέσα από την κλάση RouteDAO από την στιγμή που καμία άλλη κλάση (π.χ. SimulationEngine, Main, CustomerDAO) δεν μπορεί να το τροποποιήσει άμεσα (σύμφωνα με την αρχή της ενθυλάκωσης-Encapsulation του αντικειμενοστρεφούς προγραμματισμού). Πιο συγκεκριμένα το cache είναι εσωτερικός μηχανισμός βελτιστοποίησης καθώς δεν αποτελεί μέρος του public API της κλάσης, αποφεύγοντας με αυτόν τον τρόπο λάθος χρήση, ασυνέπειες δεδομένων και τυχαία διαγραφή των εισόδων. Ορίζεται ως static, διότι το πεδίο αυτό αποτελεί ένα μοναδικό αντίγραφο του routeStopsCache για όλη την JVM, καθώς ανήκει στην ίδια την κλάση RouteDAO και όχι σε αντικείμενα αυτής της κλάσης. Πιο συγκεκριμένα ορίζεται ως key το route_code, καθώς κάθε key είναι μοναδικό και ως value ορίζεται η λίστα πόλεων με τα stops/τις στάσεις. Το routeCode ορίζεται ως key, γιατί είναι μοναδικό και δεν αναμένεται να αλλάξει ενώ η λίστα πόλεων με τα stops τίθεται ως value, δηλαδή αφορά την σειρά των stops μίας διαδρομής, από την στιγμή που τα stops έχουν διαδοχική λογική σε ένα δρομολόγιο. 

   
	// Ο χάρτης απεικόνισης περιλαμβάνει 2 παραμέτρους (K, V), όπου η πρώτη παράμετρος είναι το Key που αντιπροσωπεύει τον τύπο του κλειδιού και είναι απλού τύπου, δηλαδή String ή Integer και η δεύτερη παράμετρος είναι το Value ου αντιπροσωπεύει τον τύπο των τιμών του δεδομένου. 
    public static HashMap<String, Double> getRoutesWithDistances() {	// Η μέθοδος αυτή είναι δημόσιας προσπέλασης, καθώς μπορεί να κληθεί προς εκτέλεση και από άλλες κλάσεις (πχ. SimulationEngine), ενώ ταυτόχρονα ανήκει στην κλάση RouteDAO και όχι σε κάποιο αντικείμενο αυτής, ενώ μέσω του HashMap<String, Double>, ορίζεται ότι το Key είναι το route_code και το value είναι η συνολική απόσταση σε χιλιόμετρα (km). Η μέθοδος επιστρέφει δομημένα δεδομένα και όχι το ResultSet.
        HashMap<String, Double> routes = new HashMap<>();		// Σε αυτό το σημείο δηλώνεται μία μεταβλητή αναφοράς με όνομα routes (HashMap<String, Double> routes), θέτονατς ως Key το (route_code) και ως Value την (συνολική απόσταση), καθώς δεν δημιουργείται ακόμα αντικείμενο, διότι δηλώνεται ότι η μεταβλητή μπορεί να δείχνει σε HashMap αυτού του τύπου. Στην συνέχεια μέσω του new HashMap<>(), δημιουργείται ένα αντικείμενο τύπου HashMap στην μνήμη heap, όπου τα δρομολόγια (routes!=null) και το routes.size() == 0, καθώςαυτό σημαίνει ότι δεν υπάρχει κανένα route και η HashMap είναι έτοιμη για να δεχθεί δεδομένα.
        String sql =										// Η μεταβλητή sql περιέχει όλο το sql query που θα σταλεί στην βάση δεδομένων, καθώς μέσω του SELECT επιλέγεται το πεδίο code από τον πίνακα routes, ενώ μέσω χρήσης του COALESCE(SUM(rs.leg_km), 0) AS total_distance αθροίζονται όλες οι αποστάσεις τoυ route, καθώς εάν το αποτέλεσμα είναι null επιστρέφεται η τιμή 0, θέτοντας ως συνθήκη FROM τον πίνακα routes. Μέσω του (LEFT JOIN route_stops rs ON r.id = rs.route_id), ανακτώνται όλες οι διαδρομές (routes), όπου μέσω χρήσης της LEFT JOIN ανακτώνται και τα routes εκείνα με μηδενική απόσταση, όπως για παράδειγμα το σημείο έναρξης από μία αποθήκη. Τέλος μέσω του GROUP BY r.id, r.code γίνεται ομαδοποίηση ανά route κάτι το οποίο είναι απαραίτητο για την συνάρτηση SUM που αφορά το άθροισμα.
                "SELECT r.code AS route_code, " +
                "COALESCE(SUM(rs.leg_km), 0) AS total_distance " +
                "FROM routes r " +
                "LEFT JOIN route_stops rs ON r.id = rs.route_id " +
                "GROUP BY r.id, r.code";

        try (Connection conn = DBConnection.getConnection();	// Σε αυτό το σημείο δημιουργείται η σύνδεση με την βάση δεδομένων καθώς χρησιμοποιείται ο JDBC Driver και τα credentials.
             Statement stmt = conn.createStatement();		// Μέσω του createStatement εκτελείται η SQL εντολή.
             ResultSet rs = stmt.executeQuery(sql)) {		// Σε αυτό το σημείο το sql ερώτημα στέλνεται στην βάση δεδομένων και η βάση εκτελεί το ερώτημα επιστρέφοντας έναν πίνακα αποτελεσμάτων, όπου το αποτέλεσμα αποθηκεύεται σε ResultSet.

            while (rs.next()) {			// Εντός του επαναληπτικού βρόγχου while για κάθε εγγραφή στον πίνακα, μετακινείται ο cursor(=κέρσορας) στην επόμενη γραμμή καθώς εκτελείται 1 φορά για κάθε δρομολόγιο, δηλαδή για κάθε route.
                String routeCode = rs.getString("route_code");		// Σε κάθε επανάληψη η μέθοδος getString διαβάζει την τιμή της στήλης route_code από την τρέχουσα γραμμή του ResultSet, καθώς η τιμή μετατρέπεται σε String και αποθηκεύεται στην μεταβλητή route_code.
                double totalDistance = rs.getDouble("total_distance");		// Η JDBC διαβάζει την στήλη total_diastance και στην περίπτωση που εάν η τιμή στην βάση ήταν null τότε θα επέστρεφε ως αποτέλεσμα το 0.0.
                routes.put(routeCode, totalDistance);			// Για το αντικείμενο routes, το οποίο είναι αντικείμενο του HashMap, όπου το Key είναι το routeCode και Value είναι το totalDistance, καθώς ο πίνακας routes(=που περιέχει τις διαδρομές) αποτελεί έναν πίνακα αντιστοίχησης, όπου το route_code αντιστοιχίζεται με μία συγκεκριμένη συνολική απόσταση για μία συγκεκριμένη οδική διαδρομή. Η μέθοδος put(key, value), προσθέτει το ζεύγος κλειδιού/τιμής στην απεικόνιση, όπου εάν το key δεν υπάρχει τότε δημιουργείται μία νέα εγγραφή ενώ εάν το key υπάρχει τότε αντικαθίσταται η παλιά τιμή. Πιο συγκεκριμένα όταν η μέθοδος αυτή εκτελείται πάνω στο αντικείμενο routes τότε παράγεται ένας ακέραιος αριθμός hash (routeCode.hashCode()), το hash μετατρέπεται σε θέση πίνακα και εκεί θα αποθηκευθεί το ζεύγος (key, value), όπου εάν υπάρχει ήδη ίδιο key τότε γίνεται overwrite το value ενώ εάν δεν υπάρχει ίδιο key τότε δημιουργείται νέο Map.Entry (επιστροφή του συνόλου των στοιχείων ως αντικείμενα Map.Entry από την στιγμή που κάθε αντικείμενο της απεικόνισης υλοποιεί την διεπαφή Map.Entry) και στην συνέχεια το double totalDistance γίνεται autoboxing → Double (δηλαδή αυτόματα η Java κάνει Double.valueOf(totalDistance)) και αποθηκεύεται ως value. Αυτό έχει ως αποτέλεσμα την εξασφάλιση μοναδικότητας στον πίνακα routes, καθώς 1 route_code (οδικό γράφημα) υπάρχει μόνο 1 φορά, κάθε διαδρομή (route) έχει ακριβώς 1 συγκεκριμένη συνολική απόσταση ενώ ταυτόχρονα εξασφαλίζεται ακεραιότητα στο αποτέλεσμα, καθώς δεν υπάρχουν διπλές τιμές. Επιπλέον σε σχέση με το GROUP BY r.id, r.code, εξασφαλίζεται ότι κάθε route_code επιστρέφεται μία φορά καθώς το HashMap δεν θα κάνει overwrite. Στην ουσία με την μέθοδο put(key, value) επιτυγχάνεται για 1 συγκεκριμένο route να αποθηκευθεί η συνολική του απόσταση έτσι ώστε να μπορεί να χρησιμοποιηθεί άμεσα χωρίς να σταλθεί πάλι ερώτημα άμεσα ως προς την βάση.  
            }		// Έχει γίνει επεξεργασία σε όλες τις γραμμές του ResultSet και το HashMap είναι πλήρες.

        } catch (SQLException e) {		// Σε περίπτωση σφαλμάτων σύνδεσης ή αποτυχίας ανάγνωσης ResultSet εκτυπώνεται στην κονσόλα ένα μήνυμα σφάλματος με λεπτομέρειες για debugging από ον προγραμματιστή.
            e.printStackTrace();
        }

        return routes;		// Σε αυτό το σημείο δεν αντιγράφεται το αντικείμενο, αλλά επιστρέφεται η αναφορά στο ίδιο αντικείμενο HashMap καθώς μόλις κληθεί η μέθοδος HashMap<String, Double> r = getRoutesWithDistances() επιστρέφεται το ίδιο αντικείμενο που δημιουργήθηκε από αυτή την μέθοδο. Στην ουσία το return routes εκτελείται μόλις κλείσουν αυτόματα το Connection, Statement και ResultSet και με αυτόν τον τρόπο δεν υπάρχουν ανοιχτοί πόροι όταν επιστρέφονται τα δεδομένα, καθώς παραδίδεται μόνο το αποτέλεσμα, δηλαδή όλα τα routes με τις αποστάσεις τους που υπολόγισε από τη βάση και την χρήση αυτών στο simulation που αφορά το επίπεδο της εφαρμογής πλέον. Αυτό έχει ως αποτέλεσμα να ολοκληρώνεται η εύθυνη του DAO μέσω της απομόνωσης της βάσης από το υπόλοιπο σύστημα δίνοντας και την δυνατότητα μελλοντικών αλλαγών στην Βάση Δεδομένων.
    }

    
    // Η μέθοδος αυτή ανήκει στο επίπεδο DAO (Data Access Object) επιστρέφοντας την λίστα πόλεων με τις στάσεις (stops) για ένα συγκεκριμένο δρομολόγιο (route), όπου στην ουσία απομωνόνεται το SQL, JDBC, DBConnection από την υπόλοιπη εφαρμογή ακολουθώντας το DAO pattern και την βελτιστοποίηση της μνήμης cache.
   // Στην ουσία η μέθοδος getRouteStops αποτελεί έναν χάρτη (Map), όπου το key είναι το route_code (πχ. Κοζάνη - Ιωάννινα) ενώ το Value είναι το List<String>, που αντιπροσωπεύει τις ενδιάμεσες στάσεις του συγκεκριμένου route(=δρομολογίου) και είναι για παράδειγμα (Κοζάνη, Καστοριά, Φλώρινα, Ιωάννινα).
    public static List<String> getRouteStops(String routeCode) {		// Η κλήση της μεθόδου αυτής μπορεί να γίνει από οπουδήποτε, διότι είναι δημόσιας προσπέλασης, δεν χρειάζεται να δημιουργηθεί αντικείμενο RouteDAO για την χρήση και κλήση αυτής της μεθόδου, καθώς επιστρέφει την σειρά των πόλεων για ένα συγκεκριμένο route_code (ως αναγνωριστικό).  
        if (routeStopsCache.containsKey(routeCode)) {		// Η μέθοδος boolean containsKey(key), επιστρέφει αποτέλεσμα true εάν το συγκεκριμένο κλειδί υπάρχει. Στην ουσία καλείται εντός της μεθόδου ελέγχοντας εάν το route έχει ήδη φορτωθεί, όπου σε αυτή την περίπτωση δεν γίνεται query (ερώτημα) προς την βάση δεδομένων καθώς επιστρέφονται τα ήδη αποθηκευμένα δεδομένα από την μνήμη cache, από την στιγμή που τα δρομολόγια (routes) δεν αλλάζουν και το ίδιο route (δρομολόγιο) μπορεί να ζητηθεί παραπάνω από 1 φορές. Στην περίπτωση που η συνθήκη δώσει αποτέελσμα true εκτελείται το block κώδικα τςη δομής διακλάδωσης if παρακάμπτοντας SQL, Connection, PreparedStatement, ResultSet.  
            return routeStopsCache.get(routeCode);		// Η μέθοδος get(key), είναι υπεύθυνη για την λήψη τιμής από μία απεικόνιση, καθώς επιστρέφει την τιμή του στοιχείου δεδομένων, το οποίο προσδιορίζεται από την τιμή του συγκεκριμένου κλειδιού, όπου στην προκειμένη περίπτωση ανακτάται η τιμή που αντιστοιχεί στο key επιστρέφοντας την List<String> από την στιγμή που δεν δημιουργείται ίδιο αντικείμενο, δεν αντιγράφεται η λίστα και επιστρέφεται το ίδιο reference ως προς το αντικείμενο στην μνήμη, καθώς επιστρέφεται η List<String> με τις πόλεις (stops) του συγκεκριμένου route, όπως αυτή έχει ήδη αποθηκευτεί στη μνήμη (cache), χωρίς να εκτελεστεί καθόλου το SQL query, από την στιγμή που δεν γίνεται σύνδεση με την βάση, εκτέλεση SQL ερωτήματος, δημιουργία ResultSet, φόρτωση δεδομένων τερματίζοντας την μέθοδο αμέσως, διότι επιστρέφεται μία λίστα από String, δηλαδή τα ονόματα των πόλεων με τις στάσεις ενός route, δηλαδή η ήδη αποθηκευμένη λίστα πόλεων του route από τη μνήμη (cache). 
        }

        // Δημιουργία λίστας αποτελεσμάτων.
        List<String> stops = new ArrayList<>();		// Δημιουργία ενός νέου αντικειμένου ArrayList στην μνήμη heap, καθώς η μεταβλητή stops αποτελεί μία αναφορά (reference) ως προς αυτό το αντικείμενο, με αποτέλεσμα την δυναμική αλλαγή μεγέθους της ArrayList για το πόσες στάσεις (stops) έχει ένα συγκεκριμένο δρομολόγιο (route).
        String sql = "SELECT rs.city_name " +		// Εντός της μεταβλητής sql εκχωρείται ένα sql ερώτημα προς την βάση δεδομένων, όπου μέσω του SELECT λαμβάνεται μόνο η στήλη city_name (που αφορά το όνομα της πόλης), από τον πίνακα routes ενώ οι 2 πίνακες συνδέονται μέσω του JOIN όπου για κάθε route (διαδρομή) βρίσκονατι οι στάσεις (τα stops) από την στιγμή που 1 route(δρομολόγιο) έχει πολλά stops (πολλές στάσεις), καθώς μέσω του WHERE φιλτράρεται ένα συγκεκριμένο route, ενώ το ? αποτελεί μία τιμή που θα συμπληρωθεί αργότερα, προστατεύοντας από SQL Injection και μέσω του ORDER BY τα stops έχουν μία συγκεκριμένη σειρά καθώς το stop_id αποτελεί την θέση ενός route εξασφαλίζονατς σωστή ακολουθία. 
                     "FROM routes r " +
                     "JOIN route_stops rs ON r.id = rs.route_id " +
                     "WHERE r.code = ? " +
                     "ORDER BY rs.stop_id ASC"; 		// Χρήση του stop_id για καλύτερη οργανωσιακή σειρά.

        try (Connection conn = DBConnection.getConnection();		// Εντός του try μπλοκ καλείται η μέθοδος DBConnection.getConnection(), ανοίγοντας την σύνδεση με την βάση δεδομένων και επιστρέφοντας ένα αντικείμενο Connection, καθώς το αντικείμενο αποθηκεύεται στην μεταβλητή conn. 
             PreparedStatement ps = conn.prepareStatement(sql)) {		// Σε αυτό το σημείο η βάση δεδομένων λαμβάνει το SQL ερώτημα, το προμεταγλωτίζει και δημιουργείται το execution plan εκτέλεσης του συγκεκριμένου query, καθώς δημιουργείται αντικείμενο PreparedStatement.

            ps.setString(1, routeCode);		// Σε αυτό το σημείο το πρώτο ? στο SQL query αντικαθίσταται με την τιμή routeCode όπου στην ουσία η Java δένει την τιμή routeCode στον 1ο placeholder ? του SQL, εξασφαλίζοντας σωστή εκτέλεση, ασφάλεια και απόδοση, χωρίς να αλλοιώνεται το SQL ερώτημα.

            try (ResultSet rs = ps.executeQuery()) {	  // Σε αυτό το σημείο πραγματοποιείται η εκτέλεση του SQL ερωτήματος παράγοντας έναν πίνακα αποτελεσμάτων με γραμμές και στήλες, καθώς ο JDBC driver δένει τα αποτελέσματα αυτά σε ένα ResultSet επιστρέφοντας αυτό το ResultSet κι όχι τα δεδομένα άμεσα.
                while (rs.next()) {						// Εντός του επαναληπτικού βρόγχου και για κάθε επανάληψη μετακινείται ο κέρσορας(cursor), από πριν την πρώτη γραμμή στην επόμενη γραμμή για όσο υπάρχουν εγγραφές μέσα στον πίνακα καθώς μόλις έχει διατρέξει όλες τις εγγραφές του πίνακα επιστρέφει το αποτέλεσμα false.
                    stops.add(rs.getString("city_name")); 		// Σε αυτό το σημείο διαβάζεται η τιμή της στήλης (city_name), καθώς ο JDBC driver εντοπίζει την στήλη city_name από την βάση δεδομένων, διαβάζει την τιμή της τρέχουσας γραμμής, την μετατρέπει σε String και την επιστρέφει. Στην συνέχεια μέσω της μεθόδου add προστίθενται η πόλη στην λίστα καθώς κάθε γραμμή από την βάση δεδομένων μετατρέπεται σε String και προστίθεται στο List<String> stops.
                }
            }		// Όταν ολοκληρωθεί το μπλοκ κώδικα try, καλείται το rs.close() κλείνοντας τον κέρσορα (cursor) και απελευθερώνει πόρους από την βάση αποφεύγοντας τα memory leaks (διαροές στην μνήμη).

        } catch (SQLException e) {		// Χωρίς να διακοπεί το πρόγραμμα εκτυπώνεται κάποιο από τα πιθανά σφάλματα (λάθος SQL, πρόβλημα σύνδεσης, λάθος όνομα στήλης) για αποσφαλμάτωση από τον προγραμματιστή.
            e.printStackTrace();
        }

        routeStopsCache.put(routeCode, stops);		// Σε αυτό το σημείο μέσω της μεθόδου put ελέγχεται αν υπάρχει ήδη το key routeCode στο routeStopsCache, καθώς αν υπάρχει τότε αντικαθιστά την παλιά λίστα με την καινούργια (stops), ενώ αν δεν υπάρχει τότε προσθέτει νέο ζευγάρι (key → value). Πιο συγκεκριμένα το routeStopsCache είναι Map<String, List<String>> και μέσω του put(key, value) αποθηκεύει το αντικείμενο value στη μνήμη με το κλειδί key, καθώς αυτό έχει ως αποτέλεσμα η επόμενη κλήση getRouteStops(routeCode) να επιστρέψει τη λίστα απευθείας από τη cache, χωρίς SQL query. Το pattern αυτό είναι βασισμένο στην αρχιτεκτονική Read-through caching pattern φορτώνοντας από την βάση δεδομένων μία φορά και διατηρούνται στην μνήμη δεδομένα για γρηγορότερη πρόσβαση. Στην συνέχεια επιστρέφεται η λίστα με τις στάσεις των πόλεων για ένα συγκεκριμένο route με την σωστή σειρά λόγω χρήσης του ORDER BY rs.stop_id ASC., εξασφαλίζοντας έτσι απομόνωση της λογικής πρόσβασης των δεδομένων. Πιο συγκεκριμένα μέσω του cache.put() αποθηκεύεται το αποτέλεσμα για μελλοντική χρήση, βελτιστοποιώντας την απόδοση ενώ μέσω του return stops επιστρέφεται άμεσα η λίστα με τις στάσεις των πόλεων.
        return stops;
    }
}	// εδώ κλείνει η κλάση RouteDAO.
