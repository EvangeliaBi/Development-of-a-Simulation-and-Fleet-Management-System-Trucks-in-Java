package simulator;		// Η κλάση CustomerDAO και η ένθετη (εσωτερική) κλάση αυτής που είναι η (Customer), ανήκουν σε αυτό το πακέτο.

// Τα παρακάτω imports χρησιμοποιούνται για σύνδεση με βάση δεδομένων, αποθήκευση δεδομένων και τυχαία προσομοίωση ωρών των διαδρομών (trips).
import java.sql.*;		// Κάνοντας import το πακέτο java.sql με τον αστερίσκο εισάγονται όλες οι κλάσεις αυτού του πακέτου που τις χρειαζόμαστε, δηλαδή οι JDBC classes (Connection, Statement, PreparedStatement, ResultSet, SQLException) για πρόσβαση στην βάση δεδομένων και στο MySQL Workbench.
import java.util.ArrayList;  	// Εδώ γίνεται import η κλάση (ArrayList) από το πακέτο java.util, όπου αυτή η κλάση υλοποιεί την διεπαφή List, για την αποθήκευση δεδομένων λιστών πελατών και ωρών, καθώς ένα αντικείμενο ArrayList είναι παρόμοιο με έναν πίνακα για την αποθήκευση αντικειμένων, μόνο που το αντικείμενο ArrayList χρησιμοποιείται ως ένας δυναμικός μονοδιάστατος πίνακας, μέσω του οποίου υπάρχει η δυνατότητα αύξησης ή μείωσης μεγέθους ύστερα από προσθήκη ή αφαίρεση κάποιων στοιχείων από μία συγκεκριμένη θέση, καθώς η χρήση της ArrayList εξασφαλίζει δυνατότητα δυναμικής μετατροπής του μεγέθους της σε αντίθεση με έναν πίνακα (όπου το μέγεθός του δεν μπορεί να αλλάξει στην συνέχεια), εξασφαλίζοντας την δυνατότητα προσθήκης ή αφαίρεσης στοιχείων από την ArrayList με ταυτόχρονη προσαρμογή του μεγέθους της. Η ArrayList κληρονομεί από την διεπαφή List, όπου η List κληρονομεί από την Collection. 
import java.util.List;			// Εδώ γίνεται import από το πακέτο java.util η κλάση (List), όπου τα στοιχεία αυτής της κλάσης (List), βρίσκονται σε μία συγκεκριμένη διάταξη, καθώς η κλάση List καθορίζεται από την υπο-διεπαφή List, επεκτείνοντας αντίστοιχα την διεπαφή Collection ορίζοντας μία συλλογή για την ακολουθιακή αποθήκευση αντικειμένων.
import java.util.Random;		// Εδώ γίνεται import από το πακέτο java.util η κλάση (Random), για την παραγωγή τυχαίων ωρών για τις διαδρομές (trips). Το οποίο ως λειτουργικότητα θα χρησιμοποιηθεί στην περίπτωση εμφάνισης αποτελεσμάτων μέσω εκτέλεσης του stochastic simulation. Στην ουσία η κλάση Random, αποτελεί μία γεννήτρια ψευδοτυχαίων αριθμών, δημιουργώντας ένα αντικείμενο αυτής της κλάσης.

public class CustomerDAO {		// Η δημιουργία δημόσιας κλάσης (CustomerDAO - Data Access Object), ακολουθεί την αρχιτεκτονική (DAO pattern), όπου στην ουσία πραγματοποιείται διαχωρισμός της διαχείρισης δεδομένων από την λογική της εφαρμογής, από την στιγμή που τα queries και η μετατροπή των αποτελεσμάτων σε αντικείμενα Customer πραγματοποιούνται εδώ κι όχι σε άλλες κλάσεις.  

    public static class Customer {		// Η στατική ένθετη κλάση (Customer), αντιπροσωπεύει ένα μοντέλο πελάτη μέσω χρήσης των απαραίτητων πεδίων παρακάτω για την αντιστοίχηση αυτών με την βάση δεδομένων (customer_id, name, city κλπ.), καθώς δηλώνεται ως static από την στιγμή που δεν είναι απαραίτητη η δημιουργία αντικειμένου (CustomerDAO) για να μπορέσει να χρησιμοποιηθεί.
        public int id;		// μοναδικός αναγνωριστικός αριθμός του κάθε πελάτη που λαμβάνεται από την βάση.
        public String name;		// όνομα πελάτη
        public String city;		// πόλη στην οποία βρίσκεται ο πελάτης
        public String type;    	// διαχωρρισμός εισροών και εκροών προιόντος ανάλογα τον τύπο του πελάτη (producer/consumer).
        public String warehouseType; 		// διαχωρισμός της αποθήκης με βάση αν είναι short term ή long term. Αυτό το πεδίο είναι σημαντικό για την σωστή επιλογή του warehouse όταν θα τρέξει το simulation.
        public int weeklyTrips;			// αριθμός εβδομαδιαίων ταξιδιών/δρομολογίων που θα προγραμματιστούν για αυτόν τον πελάτη, καθώς αυτό το πεδίο θα χρησιμοποιηθεί για τον υπολογισμό των ωρών των trips (getTripHours() / getRandomTripHours().
        public int volumePerTrip;		// ποσότητα προιόντος που μεταφέρεται ανά ταξίδι, καθώς το πεδίο αυτό είναι σημαντικό για τον υπολογισμό revenue, cost και profit κατά την εκτέλεση του simulation.

        
        // Δημιουργία του κατασκευαστή Customer και αρχικοποίηση των πεδίων ενός αντικειμένου Customer με όλες τις απαραίτητες πληροφορίες. Τα πεδία αυτά αναπαριστούν όλα τα δεδομένα που απαιτούνται για την δρομολόγηση και τον υπολογισμό του κέρδους σε 6 μήνες, διασφαλίζοντας εύκολη την διαδικασία δημιουργίας αντικειμένων σύμφωνα με τα δεδομένα που είναι καταχωρημένα στην βάση, καθώς θα υποστηριχθεί η δυνατότητα Data Mapping από το ResultSet της SQL πάνω σε ένα αντικείμενο.
        // Ο κατασκευαστής εξασφαλίζει ότι ένα αντικείμενο Customer έχει πλήρως αρχικοποιηθεί και είναι έτοιμο για να χρησιμοποιηθεί στην προσωμοίωση.
        public Customer(int id, String name, String city, String type, String warehouseType, int weeklyTrips, int volumePerTrip) {
            this.id = id;
            this.name = name;
            this.city = city;
            this.type = type;
            this.warehouseType = warehouseType;
            this.weeklyTrips = weeklyTrips;
            this.volumePerTrip = volumePerTrip;
        }

        
        // Η παρακάτω μέθοδος της κλάσης Customer, επιστρέφει μία λίστα ακεραίων (List<Integer>), όπου κάθε αριθμός αντιπροσωπεύει μία ώρα μέσα στην εβδομάδα (0–167) κατά την οποία εκτελείται ένα δρομολόγιο για τον πελάτη.
        public List<Integer> getTripHours() {		// Η μέθοδος αυτή χρησιμοποιείται για δρομολόγια (trips) που είναι ισοκατανεμημένα και ήδη καθορισμένα.
            List<Integer> hours = new ArrayList<>();		// Σε αυτό το σημείο δημιουργείται μία κενή λίστα τύπου ArrayList για την αποθήκευση των ωρών των trips, καθώς η δυναμική δομή που προσφέρρει η ArrayList, δίνει την δυνατότητα προσθήκης ωρών μέσω χρήσης της μεθόδου Add().
            int interval = 168 / weeklyTrips; 				// Σε αυτό το σημείο υπολογίζεται το διάστημα σε ώρες μεταξύ των δρομολογίων (trips) μέσα στην εβδομάδα, καθώς η εβδομάδα έχει 168 ώρες (24 * 7), όπου όταν ένας πελάτης έχει 2 trips την εβδομάδα (168 / 2 = 84), τότε τα trips θα προγραμματιστούν ισοκατανεμημένα κάθε 84 ώρες, δηλαδή περίπου κάθε μισή εβδομάδα. Στην ουσία εδώ γίνεται υπολογισμός, δηλαδή πόσο να απέχουν τα trips προκειμένου να είναι ισοκατανεμημένα.
            for (int i = 0; i < weeklyTrips; i++) {		// Σε μία επαναληπτική δομή for, όπου η συνθήκη θα φτάσει να ισχύει μέχρι όσο είναι τα εβδομαδιαία δρομολόγια (weeklyTrips) του κάθε πελάτη, καθώς κάθε επανάληψη αντιστοιχεί σε ένα δρομολόγιο το οποίο πρέπει να προγραμματιστεί προς έναν πελάτη.
                hours.add(i * interval);			// Για όσο η συνθήκη δίνει true και ισχύουν τα εβδομαδιαία δρομολόγια ενός πελάτη, τότε εντός της επανάληψης πραγματοποιείται η προσθήκη της ώρας του τρέχοντος δρομολογίου (trip) μέσα στην λίστα hours, μέσω χρήσης της μεθόδου add. Η λογική που υπάρχει πίσω από την χρήση αυτής της επαναληπτικής δομής είναι ότι όταν το i = 0 εκτελείται το πρώτο trip κι άρα 0 * interval = 0 (το οποίο σηματοδοτεί την αρχή της εβδομάδας). Όταν το i = 1 εκτελείται το δεύτερο trip κι άρα 1 * interval = 84 (που σηματοδοτεί την μέση της εβδομάδα). Κι  όταν το i = 2 τότε εκτελείται το τρίτο trip κι άρα 2 * interval = 168/3, κ.ο.κ. Στην ουσία εδώ προστίθεται το κάθε trip στην λίστα πολλαπλασιάζοντας το διάστημα με το index του trip.
            }
            return hours;		// Μόλις ολοκληρωθεί η επανάληψη και δώσει η συνθήκη αποτέλεσμα faulse τότε βγαίνουμε εκτός επανάληψης κι αυτό είναι το σημείο όπου επιστρέφεται η λίστα με τις ώρες των δρομολογίων (trips). Πιο συγκεκριμένα η κλάση SimulationEngine χρησιμοποιεί αυτή τη λίστα για να προγραμματίσει πότε θα εκτελούνται τα trips κατά τη διάρκεια της εβδομάδας.
        }
        
        // Παρακάτω στην μέθοδο οι ώρες επιλέγονται από ολόκληρο το εύρος(0-167), καθώς μπορεί να είναι οποιοσδήποτε συνδυασμός (Δευτέρα & Παρασκευή, Τρίτη & Κυριακή), αλλά πάντα με βάση τα 2 trips την εβδομάδα, καθώς η μέθοδος δεν μπορεί να ολοκληρωθεί αν δεν βρει ακριβώς 2 ώρες μέσα στην εβδομάδα(0-167), εργάσιμες ώρες(08:00-19:59) και να είναι διαφορετικές μεταξύ τους.
        public List<Integer> getRandomTripHours() {		// Η μέθοδος αυτή της κλάσης Customer, επιστρέφει μία λίστα από (Integers), όπου αντιπροσωπεύουν μία ώρα μέσα στην εβδομάδα (από 0-167), καθώς αυτή η μέθοδος έχει ως σκοπό την δημιουργία τυχαίων ωρών ανά δρομολόγιο (trip), με την βάση όμως ότι γίνονται 2 δρομολόγια την εβδομάδα.
            List<Integer> hours = new ArrayList<>();	// Σε αυτό το σημείο, δημιουργείται μία κενή δυναμικού μεγέθους ArrayList, η οποία αποθηκεύει τυχαίες ώρες για κάθε trip, καθώς οι ώρες δεν είναι ισοκατανεμημένες σε περίπτωση εκτέλεσης αυτής της μεθόδου.
            Random rand = new Random();				// Μέσω της κλάσης Random, δημιουργείται ένα αντικείμενο αυτής της κλάσης, το οποίο αποτελεί μία γεννήτρια παραγωγής ψευδοτυχαίων αριθμών.
            while (hours.size() < weeklyTrips) {		// Ο επαναληπτικός βρόγχος της while θα εξακολουθεί να τρέχει μέχρι ο αριθμός των ωρών που βρίσκεται μέσα στην λίστα να ισοδυναμεί με το weeklyTrips, δηλαδή τα εβδομαδιαία δρομολόγια (όπου αριθμός των ωρών στη λίστα == weeklyTrips). Πιο συγκεκριμένα εάν το weeklyTrips = 3, τότε ο βρόχος θα συνεχίζεται μέχρι η λίστα να έχει 2 διαφορετικές ώρες, καθώς ο βρόγχος αυτός δεν έχει σίγουρο αριθμό επαναλήψεων, διότι βασίζεται στην τυχαία παραγωγή ωρών ανά δρομολόγιο.
                int h = rand.nextInt(168); 				// Εδώ παράγεται μία τυχαία ώρα μέσα στην εβδομάδα, αντιπροσωπεύοντας μία συγκεκριμένη ώρα της εβδομάδας (0 ≤ h ≤ 167, δηλαδή h = 35 → Τρίτη 11:00 και h = 140 → Κυριακή 20:00) και το αποτέλεσμα αποθηκεύεται σε μία μεταβλητή h.
                int hourOfDay = h % 24;					// Σε αυτό το σημείο υπολογίζεται η ώρα της ημέρας (0-23), όπου κάθε 24 ώρες αλλάζει η ημέρα (πχ. h = 35 → 35 % 24 = 11 → 11:00).
                if (hourOfDay >= 8 && hourOfDay < 20) { 		// Σε αυτό το σημείο πραγματοποιείται ένας έλεγχος των εργάσιμων ωρών (δηλαδή ελέγχεται εάν η ώρα είναι μεταξύ 08:00 έως 19:59) και τότε επιτρέπεται το trip(δρομολόγιο), ενώ στην περίπτωση που η συνθήκη δεν ικανοποιείται τότε απορρίπτεται το δρομολόγιο, διασφαλίζοντας ότι κανένα trip δεν γίνεται την νύχτα. Στην ουσία κρατιούνται μόνο οι εργάσιμες ώρες.
                    if (!hours.contains(h)) {			// Μέσω της ένθετης δομής διακλάδωσης if, ελέγχεται εάν η συγκεκριμένη ώρα (h) δεν υπάρχει ήδη στην λίστα, καθώς αυτό εξασφαλίζει ότι δεν θα υλοποιούνται 2 δρομολόγια την ίδια ώρα, διασφαλίζοντας ότι δεν θα υπάρχει διπλομέτρηση.
                        hours.add(h);			// Σε αυτό το σημείο πραγματοποιείται η προσθήκη ώρας στην λίστα, καθώς αυτή η προσθήκη θα πραγματοποιηθεί μόλις δώσει αποτέλεσμα true ο πρώτος έλεγχος και διαπιστωθεί ότι η ώρα είναι εργάσιμη και μόλις δώσει αποτέλεσμα true και ο δεύτερος έλεγχος στην περίπτωση που η παραγωγή της τυχαίας αυτής ώρας δεν υπάρχει ήδη στην λίστα και τότε πραγματοποιείται η προσθήκη αυτής.
                    }
                }
            }		// Εδώ κλείνει ο βρόγχος της while, καθώς θα συνεχιστεί μέχρι να συμπληρωθούν όλα τα weeklyTrips.
            return hours;		// Σε αυτό το σημείο επιστρέφεται η λίστα με τις τυχαίες έγκυρες ώρες των trips.
        }
   
    }	// Εδώ κλείνει η ένθετη κλάση Customer.

    
    // Η μέθοδος αυτή επιστρέφει όλους τους πελάτες, καθώς ανήκει στο επίπεδο DAO layer, ανήκει δηλαδή στην CustomerDAO κλάση, φορτώνει τα δεδομένα από την βάση, τα μετατρέπει σε αντικείμενα (Customers) καθώς επιστρέφει καθαρό domain model στο πρόγραμμα προσομοίωσης(simulation).
    public static List<Customer> getAllCustomers() {		// Πιο συγκεκριμένα η μέθοδος είναι δημόσιας προσπέλασης καθιστώντας την προσβάσιμη από οποιοδήποτε σημείο της εφαρμογής και είναι static, καθώς δεν απαιτείται η δημιουργία αντικειμένου CustomerDAO για την χρήση αυτής της μεθόδου ενώ ταυτόχρονα επιστρέφει μία λίστα (συλλογή) με όλους τους πελάτες. Η λογική της προσομοίωσης επικεντρώνεται μόνο στην λήψη όλων των πελατών καθώς δεν την αφορά το πώς ανακτήθηκαν όλοι αυτοί οι πελάτες.
        List<Customer> customers = new ArrayList<>();		// Μέσω χρήσης της κενής δυναμικής λίστας θα αποθηκεύονται αντικείμενα τύπου Customer, καθώς δηλώνεται ως τύπου List(interface) αλλά υλοποιείται ως ArrayList με συγκεκριμένη δομή, καθώς με αυτόν τον τρόπο επιτρέπεται η προσθήκη οποιουδήποτε αριθμού πελατών καθώς αυτό καθιστά δυνατό την δυνατότητα επαναλήψεων, φιλτραρίσματος πελατών και την εκτέελση των διαφόρων simulations.
        String sql = "SELECT * FROM customers";			// Εδώ ορίζεται η εκτέλεση του SQL ερωτήματος προς την βάση δεδομένων, καθώς ανακτώνται λόγω του (*), όλες οι στήλες και τα πεδία που φτιάξαμε πάνω από τον πίνακα customers της βάσης δεδομένων MySQL Workbench.

        try (Connection conn = DBConnection.getConnection();		// Σε αυτό το σημείο μπορούμε να δούμε το αντικείμενο της σύνδεσης, όπου το DBConnection απομονώνει τα credentials, URL, driver, από την στιγμή που το simulation program δεν το αφορά ζητήματα που σχετίζονται με την βάση δεδομένων (host, database, passwords). Στην ουσία εδώ είναι το σημείο που δημιουργείται το SQL Statement και πραγματοποιείται η σύνδεση στην βάση μέσω της διεπαφής Connection.
             Statement stmt = conn.createStatement();		// Αφού ήδη έχει δημιουργηθεί το αντικείμενο Connection για την σύνδεση με την βάση δεδομένων, στην συνέχεια δημιουργούνται τα αντικείμενα Statement μέσω των οποίων ορίζονται κι εκτελούνται συγκεκριμένες SQL ερωτήσεις, όπου ένα αντικείμενο Statement δημιουργείται με την μέθοδο createStatement() ενός αντικειμένου Connection, καθώς αφού δημιουργηθεί το Statement αντικείμενο, πραγματοποιείται η εκτέλεση αυτού μέσω της μεθόδου executeQuery() μεταβιβάζοντας ένα αλφαριθμητικό με το κείμενο της SQL ερώτησης. Πιο συγκεκριμένα, η μέθοδος createStatement(), δημιουργεί το statement, το οποίο αντιπροσωπεύει το αντικείμενο της κλάσης Statement, καθώς αυτό το αντικείμενο θα χρησιμοποιηθεί για ερωτήματα προς την βάση δεδομένων.
             ResultSet rs = stmt.executeQuery(sql)) {		// Εδώ πραγματοποιείται εκτέλεση του sql ερωτήματος μέσω κλήσης της μεθόδου executeQuery() που υπάρχει μέσα στο PreparedStatement και αποστολή του query στον sql server(της βάσης δεδομένων) για εκτέλεση του query κι εκχώρηση σε μία μεταβλητή rs τύπου ResultSet αφού μέσω εκτέλεσης της μεθόδου executeQuery() επιστρέφεται ένα αντικείμενο τύπου ResultSet(όπου όλες οι εγγραφές εμφανίζονται σε μορφή πίνακα με σειρές και στήλες), καθώς το rs δεν περιέχει όλα τα δεδομένα στην μνήμη λειτουργώντας σαν cursor(=κέρσορας) που σημαίνει ότι βρίσκεται πριν από την πρώτη γραμμή. Μόλις ο κώδικας προχωρήσει έξω από το try μπλοκ τότε το ResultSet κλείνει αυτόματα. Στην ουσία η ResultSet είναι μία διεπαφή, που περιέχει τα αποτελέσματα που λαμβάνονται από την εκτέλεση των SQL εντολών καθώς μέσω χρήσης της μεθόδου ResultSet είναι εφικτή η διαχείριση των δεδομένων.

            while (rs.next()) {			// Εντός του επαναληπτικού βρόγχου while χρησιμοποιείται while κι όχι for, διότι δεν γνωρίζουμε πόσες εγγραφές υπάρχουν αφού το πλήθος καθορίζεται από την βάση δεδομένων και απαιτείται data-driven επανάληψη, όπου κάθε επανάληψη αντιστοιχεί σε μία γραμμή SQL (δηλαδή 1 αντικείμενο Customer), κι έτσι σε κάθε επανάληψη, η μέθοδος next() μετακινεί τον κέρσορα (cursor) του ResultSet στην επόμενη γραμμή, επιστρέφοντας αποτέλεσμα true εάν υπάρχει επόμενη γραμμή ενώ στην περίπτωση που ο πίνακας έχει φτάσει στο τέλος όλων των εγγραφών τότε επιστρέφει αποτέλεσμα false. H διεπαφή ResultSet παρέχει κάποιες μεθόδους get(), για την επιστροφή των διάφορων τύπων δεδομένων κάθε γραμμής.   
                customers.add(new Customer(		// Σε κάθε επανάληψη δημιουργείται ένα αντικείμενο Customer και μέσω της μεθόδου add, πραγματοποιείται η προσθήκη αυτού του αντικειμένου εντός της λίστας customers. Στην ουσία εδώ πραγματοποιείται object materialization, όπου μετατρέπονται τα raw sql δεδομένα σε domain model.
                        rs.getInt("customer_id"),		// Σε αυτό το σημείο διαβάζεται η τιμή της στήλης (customer_id) και μετατρέπεται αντίστοιχα σε τύπο δεδομένου int.
                        rs.getString("customer_name"),		// Εδώ διαβάζεται το όνομα του πελάτη και επιστρέφει ένα String, δηλαδή επιστρέφεται το όνομα του πελάτη από την βάση δεδομένων.
                        rs.getString("city_name"),			// Εδώ ανακτάται η πόλη του πελάτη από την βάση δεδομένων, καθώς θα χρησιμοποιηθεί στο routing και στο warehouse assignment αργότερα.
                        rs.getString("customer_type"),		// Ανάκτηση τύπου πελάτη (Producer/Consumer, καθώς με αυτόν τον τρόπο θα οριστεί αν πρόκειται για εισροή ή εκροή προιόντος επηρρεάζοντας αντίστοιχα το cost και το revenue.
                        rs.getString("warehouse_type"),		// Εδώ ανακτάται η πληροφορία εάν ο πελάτης έχει δεσμέυσει αποθήκη short term ή long term, επιτρέπονατς λήψη στρατηγικών αποφάσεων.
                        rs.getInt("weekly_trips"),		// Σε αυτό το σημείο ανακτώνται ό αριθμός των εβδομαδιαίων trips (δρομολογίων) που αντιστοιχούν στον κάθε πελάτη ανά βδομάδα, καθώς με αυτόν τον τρόπο καθορίζεται ο ρυθμός της ζήτησης επηρρεάζοντας αντίστοιχα το scheduling (προγραμματισμό δρομολογίων), το cost και το revenue.
                        rs.getInt("volume_per_trip")	// Σε αυτό το σημείο διαβάζεται ο όγκος (δηλαδή το φορτίο που μεταφέρει κάθε φορτηγό) ανά trip (δρομολόγιο), επηρρεάζοντας αντίστοιχα τα μεταφορικά κόστη, την χωρητικότητα και το κέρδος.
                ));
            }	// τέλος της while, καθώς τερματίζεται ο βρόγχος επιστρέφοντας false αφού δεν υπάρχουν άλλες γραμμές.

        } catch (SQLException e) {		// Χειρισμός εξαιρέσεων, οι οποίες πρέπει να είναι τύπου SQLException, καθώς η μεταβλητή e αναπαριστά αυτή την εξαίρεση που καταγράφηκε, δηλαδή λάθη σύνταξης SQL, σύνδεσης, driver, mapping.
            e.printStackTrace();		// Για το αντικείμενο (e, που αναπαριστά την καταγεγραμμένη εξαίρεση), καλείται η μέθοδος public void printStackTrace(), η οποία δίνει την δυνατότητα στον προγραμματιστή να προχωρήσει σε debugging(=αποσφαλμάτωση) του κώδικα εκτυπώνοντας στο console τις πληροφορίες για το σημείο που προέκυψε το σφάλμα δίχως την ολική κατάρευση της εφαρμογής. Η μέθοδος public void printStackTrace() ανήκει στην κλάση java.lang.Throwable(η οποία επεκτείνει την κλάση java.lang.Object) και υλοποιεί(implements την διεπαφή Serializable). Επομένως ανάγεται το συμπέρασμα ότι η κλάση Exception(που είναι η direct subclass της κλάσης Throwable) κληρονομεί την μέθοδο public void printStackTrace().
        }

        return customers;		// Κι εδώ επιστρέφεται η λίστα των πελατών, καθώς εάν δεν υπάρχουν εγγραφές μέσα στην βάση δεδομένων επιστρέφεται μία κενή λίστα αποτρέποντας την εκδήλωση NullPointerException.
    }

  
    // Στην ουσία η εφαρμογή ζητά μόνο τους πελάτες μίας πόλης ενώ η κλάση CustomerDAO μεταφράζει σε SQL αυτό το αίτημα από την εφαρμογή, τρέχει το query και στην συνέχεια επιστρέφει τα αντικείμενα, δηλαδή τους πελάτες που βρίσκονται σε αυτή την πόλη. 
    public static List<Customer> getCustomersByCity(String city) {		// Η συγκεκριμένη μέθοδος επιστρέφει όλους τους πελάτες για μία συγκεκριμένη πόλη, φιλτράροντας τα δεδομένα από την βάση δεδομένων, καθώς είναι δημόσιας προσπέλασης ορατή από οπουδήποτε, δεν απαιτεί την δημιουργία αντικειμένου CustomerDAO για να μπορέσει να κληθεί και να εκτελεστεί, επιστρέφοντας τους πελάτες εκείνους που βρίσκονται σε μία συγκεκριμένη πόλη. 
        List<Customer> customers = new ArrayList<>();		// Δημιουργία μίας δυναμικής κενής λίστας που επιστρέφεται η λίστα πελατών. 
        String sql = "SELECT * FROM customers WHERE city_name = ?";		// Εντός της μεταβλητής sql εκχωρείται ένα sql query (ερώτημα), όπου επιλέγονται όλες οι στήλες από τον πίνακα customers φιλτράροντας με το WHERE τις εγγραφές με σκοπό την λήψη μόνο εκείνων των εγγραφών που η στήλη city_name ισούται με μία παράμετρο που θα δοθεί αργότερα. Στην ουσία η χρήση του ?, επιτρέπει ασφαλή και σωστή τοποθέτηση της παραμέτρου μέσω του PreparedStatement.setString(1, city), καθώς η βάση δεδομένων έχει την δυνατότητα να προμεταγλωτίσει το query και να το χρησιμοποιήσει ξανά.

        try (Connection conn = DBConnection.getConnection();		// Εντός του try μπλοκ δημιουργείται μια σύνδεση με τη βάση δεδομένων καλώντας τη μέθοδο getConnection() της κλάσης DBConnection, καθώς με αυτόν τον τρόπο επιτρέπεται η εκτέελση των sql queries.
             PreparedStatement ps = conn.prepareStatement(sql)) {		// Εδώ δημιουργείται ένα PreparedStatement, δηλαδή προετοιμασμένο SQL query από τη μεταβλητή sql. Στην ουσία δημιουργείται ένα αντικείμενο PreparedStatement με βάση το SQL ερώτημα που ορίστηκε στη μεταβλητή sql.

            ps.setString(1, city);		// Σε αυτό το σημείο ορίζεται η πρώτη τιμή που αντικαθιστά το πρώτο ? από το sql query που τέθηκε πάνω αντιπροσωπεύοντας το όνομα της πόλης που βρίσκεται ένας πελάτης, δηλαδή το city_name, που εισήγαγε ο χρήστης κατά την εκτέλεση του simulation και που θα συγκριθεί με τις εγγραφές της βάσης.

            try (ResultSet rs = ps.executeQuery()) {	// Σε αυτό το σημείο εκτελείται το sql query και λαμβάνονται τα αποτελέσματα, καθώς επιστρέφεται ένα ResultSet. 
                while (rs.next()) {		// Εντός του επαναληπτικού βρόγχου while, διαβάζεται κάθε γραμμή από το ResultSet, καθώς μέσω της μεθόδου rs.next() μετακινείται ο δείκτης στην επόμενη εγγραφή επιστρέφοντας true στην περίπτωση που υπάρχει εγγραφή, καθώς μέσω αυτής της επαναληπτικής δομής πραγματοποιείται η επεξεργασία όλων των αποτελεσμάτων. 
                    customers.add(new Customer(		// Σε κάθε επανάληψη δημιουργείται ένα αντικείμενο Customer και προστίθεται μέσω της μεθόδου add στην λίστα customers, καθώς για κάθε γραμμή (row) του ResultSet διαβάζονται τα πεδία (customer_id, customer_name, city_name, customer_type, warehouse_type, weekly_trips, volume_per_trip) με rs.getInt() ή rs.getString().
                            rs.getInt("customer_id"),		
                            rs.getString("customer_name"),
                            rs.getString("city_name"),
                            rs.getString("customer_type"),
                            rs.getString("warehouse_type"),
                            rs.getInt("weekly_trips"),
                            rs.getInt("volume_per_trip")
                    ));
                }
            }

        } catch (SQLException e) {		// Σε αυτό το σημείο αν προκύψει οποιοδήποτε SQLException (π.χ. λάθος query, πρόβλημα σύνδεσης), η εξαίρεση τυπώνεται στην κονσόλα, καθώς η μέθοδος δεν τερματίζεται αυτόματα επιτρέποντας την δυνατότητα αποσφαλμάτωσης από τον προγραμματιστή.
            e.printStackTrace();		
        }

        return customers;		// Κι εδώ επιστρέφονται τα αποτελέσματα, δηλαδή η λίστα customers που περιέχει πλέον όλα τα αντικείμενα Customer που ικανοποιούν το query.
    }
}	// Εδώ κλείνει η κλάση CustomerDAO.
