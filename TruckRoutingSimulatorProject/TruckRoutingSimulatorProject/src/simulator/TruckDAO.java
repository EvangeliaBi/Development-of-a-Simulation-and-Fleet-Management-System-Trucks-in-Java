package simulator;

import java.sql.*;		// Εισαωγή του πακέτου για πρόσβαση στο JDBC (Connection, Statement, ResultSet, SQLException) για πρόσβαση στη βάση δεδομένων MySQL.
// Εισαγωγή των κλάσεων ArrayList και List για δυανμική αποθήκευση λιστών φορτηγών.
import java.util.ArrayList;		// Αποθήκευση οποιουδήποτε αριθμού εγγραφών, καθώς είναι ιδανική για simulation όπου οι τύποι φορτηγών μπορεί να αλλάξουν στο μέλλον.
import java.util.List;

public class TruckDAO {		// Η δημόσια αυτή κλάση βασίζεται στο DAO pattern(Data Access Object) διαχωρίζοντας τη λογική πρόσβασης στη βάση δεδομένων από τη λογική της εφαρμογής, καθώς όλη η διαχείριση των φορτηγών πραγματοποιείται σε αυτή την κλάση.

    public static class Truck {		// Σε αυτό το σημείο δηλώνεται μία στατική ένθετη κλάση Truck, καθώς δεν χρειάζεται να υπάρχει αντικείμενο TruckDAO για να δημιουργηθεί ένα φορτηγό (Truck).
        // Με τα παρακάτω πεδία πραγματοποιείται η μοντελοποίηση ενός φορτηγού, καθώς τα πεδία είναι private για ενθυλάκωση (encapsulation), δηλαδή για προστασία δεδομένων και έλεγχο πρόσβασης μέσω public μεθόδων getters/setters.
    	private String category;	// τύπος φορτηγού (π.χ., Small, Medium, Large).
        private int capacity;		// χωρητικότητα φορτηγού (σε units).
        private int quantity; 			// αριθμός διαθέσιμων φορτηγών ενός συγκεκριμένου τύπου φορτηγού

        // Δημιουργία του κατασκευαστή για αρχικοποίηση ενός αντικειμένου Truck, εξασφαλίζοντας ότι κάθε φορτηγό έχει πλήρως αρχικοποιημένα πεδία.
        public Truck(String category, int capacity, int quantity) {
            this.category = category;
            this.capacity = capacity;
            this.quantity = quantity;
        }

        // Οι Getters & Setters προσφέρουν ως μέθοδοι ασφαλή πρόσβαση στα πεδία σύμφωνα με την αρχή της ενθυλάκωσης (encapsulation) του αντικειμενοστραφούς προγραμματισμού.
        public String getCategory() { return category; }
        public int getCapacity() { return capacity; }
        public int getQuantity() { return quantity; }
        public void setQuantity(int quantity) { this.quantity = quantity; }		// Σε αυτό το σημείο το setQuantity χρησιμοποιείται για να γίνει ενημέρωση του αριθμού των διαθέσιμων φορτηγών κατά την εκτέλεση του simulation.
    
    }	// Εδώ κλείνει η ένθετη κλάση Truck.

    
    public static List<Truck> getAllTruckTypes() {		// Η στατική αυτή μέθοδος ανήκει στην κλάση TruckDAO, καθώς επιστρέφει την λίστα όλων των τύπων φορτηγών (small, medium, large).
        List<Truck> trucks = new ArrayList<>();		// Σε αυτό το σημείο δημιουργείται μία κενή λίστα (ArrayList) δυναμικού μεγέθους, καθώς σε αυτή την λίστα θα αποθηκευθούν όλα τα φορτηγά που ανακτώνται από την βάση.
        String sql = "SELECT category, capacity, quantity FROM trucks"; 	// Σε αυτό το σημείο δηλώνεται το sql query επιστρέφοντας όλα τα πεδία category, capacity, quantity από τον πίνακα trucks.

        try (Connection conn = DBConnection.getConnection();	// Σε αυτό το σημείο πραγματοποιείται κι ανοίγει η σύνδεση με την βάση δεδομένων.
             Statement st = conn.createStatement();		// Εδώ δημιουργείται ένα αντικείμενο τύπου Statement για την εκτέλεση του sql ερωτήματος προς την βάση δεδομένων.
             ResultSet rs = st.executeQuery(sql)) {		// Σε αυτό το σημείο εκτελείται το query και γίνεται επιστροφή του αποτελέσματος, όπου τα SQL αποτελέσματα μετατρέπονται σε Java objects (Truck) σύμφωνα με την αρχιτεκτονική Data Mapping pattern.

            while (rs.next()) {			// Εντός του επαναληπτικού βρόγχου while σε κάθε επανάληψη και για κάθε γραμμή αποτελεσμάτων (ResultSet-δείκτης που δείχνει σε μία συγκεκριμένη γραμμή κάθε φορά ξεκινώντας πριν από την πρώτη γραμμή) μέσω του rs.next() γίνεται η μετακίνηση στην επόμενη γραμμή του πίνακα επιστρέφοντας false όταν τελειώσουν όλες οι γραμμές του πίνακα. Στην ουσία ο JDBC driver ζητά από τη βάση την επόμενη γραμμή μετακινώντας τον κέρσορα (ResultSet) στην επόμενη γραμμή αν υπάρχουν ακόμα εγγραφές στον πίνακα επιστρέφοντας το αποτέλεσμα true, ενώ αν δεν υπάρχει άλλη γραμμή επιστρέφεται αποτέλεσμα false, διαβάζοντας με αυτόν τον τρόπο δυναμικά όσα δεδομένα υπάρχουν στην βάση. Στην ουσία εδώ σε κάθε επανάληψη μετακινείται ο κέρσορας δημιουργώντας ένα νέο αντικείμενο Truck προσθέτοντάς το στην λίστα.
                trucks.add(new Truck(		// Μόλις έχουμε όλα τα δεδομένα τότε εκτελείται η γραμμή αυτού του κώδικα, δηλαδή δεσμέυεται μνήμη στο heap και καλείται ο κατασκευαστής, καθώς οι τιμές αποθηκεύονται στα πεδία του αντικειμένου και στην συνέχεια ελέγχεται εάν υπάρχει χώρος στο εσωτερικό array, διότι εάν δεν υπάρχει τότε μεγαλώνει δυναμικά αποθηκεύοντας μία αναφορά ως προς το αντικείμενο Truck. Σε αυτό το σημείο πραγματοποιείται το Data Mapping, όπου στην ουσία μετατρέπεται η κάθε SQL γραμμή σε Java Object, καθώς πραγματοποιείται η προσθήκη κάθε αντικειμένου φορτηγού στην λίστα trucks. Στην ουσία εδώ προστίθεται το αντικείμενο Truck στην λίστα 
                        rs.getString("category"),		// Εδώ διαβάζει την στήλη category και την επιστρέφει ως String, καθώς ανακτάται η τιμή της στήλης category από την τρέχουσα γραμμή, όπου ο JDBC driver διαβάζει το περιεχόμενο της στήλης, το μετατρέπει σε String και το επιστρέφει στην JVM.
                        rs.getInt("capacity"),		// Εδώ διαβάζει την ακέραια τιμή της στήλης capacity και την μετατρέπει σε int.
                        rs.getInt("quantity")		// Εδώ διαβάζει πόσα φορτηγά ενός συγκεκριμένου τύπου (small, medium, large) υπάρχουν διαθέσιμα, κάτι το οποίο είναι πολύ σημαντικό για το simulation.
                ));
            }

        } catch (SQLException e) {		// Εδώ πραγματοποιείται ο χειρισμός πιθανών σφαλμάτων (JDBC/SQL), καθώς αν υπάρξει πρόβλημα με σύνδεση ή query, το exception τυπώνεται στο console.
            e.printStackTrace();
        }

        return trucks;		// Εδώ επιστρέφεται ολόκληρη η λίστα φορτηγών, καθώς τα αντικείμενα Trucks που είναι πλήρως αρχικοποιημένα μπορούν να χρησιμοποιηθούν στο simulation ή στη λογική διαχείρισης.
    }
}	// Εδώ κλείνει η κλάση TruckDAO.
